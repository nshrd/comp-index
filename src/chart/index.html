<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CBMA Chart - Simplified</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <script src="config.js"></script>
    <script src="optimized_utils.js"></script>
    <style>
        /* ========= ОСНОВНЫЕ СТИЛИ ========= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", sans-serif;
            background: #0D1421;
            color: #B2B5BE;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        /* ========= ВЕРХНЯЯ ПАНЕЛЬ ========= */
        .top-panel {
            height: 48px;
            background: #1E222D;
            border-bottom: 1px solid #2A2E39;
            display: flex;
            align-items: center;
            padding: 0 16px;
            justify-content: space-between;
        }

        .symbol-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .symbol-name {
            font-size: 16px;
            font-weight: 600;
            color: #FFFFFF;
        }

        .symbol-details {
            font-size: 11px;
            color: #787B86;
        }

        .price-data {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .price-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .price-label {
            font-size: 10px;
            font-weight: 500;
        }

        .price-value {
            font-size: 14px;
            font-weight: 600;
            color: #FFFFFF;
        }

        .price-change {
            font-size: 12px;
            font-weight: 500;
        }

        .price-change.positive {
            color: #00C851;
        }

        .price-change.negative {
            color: #FF4444;
        }

        /* ========= ПАНЕЛЬ ТАЙМФРЕЙМОВ ========= */
        .toolbar-panel {
            height: 40px;
            background: #1E222D;
            border-bottom: 1px solid #2A2E39;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        .toolbar-group {
            display: flex;
            gap: 2px;
        }

        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 4px;
            color: #B2B5BE;
            background: transparent;
            border: none;
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #FFFFFF;
        }

        .toolbar-btn.active {
            background: #2962FF;
            color: #FFFFFF;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: #2A2E39;
        }

        /* ========= ПАНЕЛЬ УПРАВЛЕНИЯ ========= */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px 16px;
            background: #1E222D;
            border-bottom: 1px solid #2A2E39;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #2A2E39;
            border-radius: 6px;
            font-size: 12px;
        }

        .control-group label {
            color: #B2B5BE;
            font-weight: 500;
            white-space: nowrap;
        }

        .control-group select,
        .control-group input {
            background: #131722;
            border: 1px solid #2A2E39;
            border-radius: 4px;
            padding: 4px 8px;
            color: #FFFFFF;
            font-size: 12px;
            min-width: 80px;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #2962FF;
            box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.3);
        }

        .control-btn {
            background: #2962FF;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
        }

        .control-btn:hover {
            background: #1E53E5;
        }

        .date-input {
            width: 140px !important;
        }

        /* ========= ОБЛАСТЬ ГРАФИКА ========= */
        .chart-area {
            flex: 1;
            position: relative;
            background: #0D1421;
        }

        .chart-container {
            width: 100%;
            height: 100%;
            background: #0D1421;
        }

        .status {
            position: absolute;
            top: 12px;
            right: 18px;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 0 4px rgba(0,0,0,0.2);
        }

        .status.success {
            border-color: #00C851;
            color: #00C851;
        }

        .status.error {
            border-color: #FF4444;
            color: #FF4444;
        }

        .status.info {
            border-color: #2962FF;
            color: #2962FF;
        }

        /* ========= СКРЫТЫЕ ЭЛЕМЕНТЫ ========= */
        .hidden {
            display: none;
        }

        /* ========= АДАПТИВНОСТЬ ========= */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }
            
            .control-group {
                justify-content: space-between;
            }
            
            .top-panel {
                flex-direction: column;
                height: auto;
                padding: 8px 16px;
                gap: 8px;
            }
            
            .price-data {
                justify-content: space-around;
                width: 100%;
            }
        }

        /* ========= ОСНОВЫ СКРОЛЛБАРА ========= */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1E222D;
        }

        ::-webkit-scrollbar-thumb {
            background: #2A2E39;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #363A45;
        }

        select option {
            background: #1E222D;
            color: #FFFFFF;
        }

        /* скрываем интерфейс при fullscreen */
        .fullscreen-mode .toolbar,
        .fullscreen-mode .controls {
            display: none !important;
        }

        /* растягиваем область графика на весь экран */
        .fullscreen-mode .chart-area {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: 999;
        }

        /* отключённые таймфрейм кнопки */
        .toolbar-btn.disabled {
            opacity: 0.35;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Верхняя панель -->
        <div class="top-panel">
            <div class="symbol-info">
                <div class="symbol-name">Coinbase Index Rank</div>
                <!-- subtitle removed -->
            </div>
            <!-- Блок ценовых данных удалён -->
        </div>

        <!-- Панель таймфреймов -->
        <div class="toolbar-panel">
            <div class="toolbar-group" id="timeframe-buttons">
                <button class="toolbar-btn" data-timeframe="4h">4h</button>
                <button class="toolbar-btn" data-timeframe="1D">1D</button>
                <button class="toolbar-btn" data-timeframe="3D">3D</button>
                <button class="toolbar-btn active" data-timeframe="1W">1W</button>
            </div>

            <div class="toolbar-group" id="instrument-buttons" style="margin-left: 20px;">
                <button class="toolbar-btn instrument-btn active" data-instrument="btc">BTC</button>
                <button class="toolbar-btn instrument-btn" data-instrument="spx">S&P 500</button>
                <button class="toolbar-btn instrument-btn" data-instrument="vix">VIX</button>
                <button class="toolbar-btn instrument-btn" data-instrument="dxy">DXY</button>
                <button class="toolbar-btn instrument-btn" data-instrument="total3esbtc">Total3 - BTC</button>
                <button class="toolbar-btn instrument-btn" data-instrument="withoutbtc">Without BTC</button>
                <button class="toolbar-btn instrument-btn" data-instrument="withoutbtceth">Without BTC/ETH</button>
                <button class="toolbar-btn instrument-btn" data-instrument="others">Others</button>
                <button class="toolbar-btn instrument-btn" data-instrument="othersbtc">Others BTC</button>
            </div>
        </div>

        <!-- Панель управления -->
        <div class="controls">
            <div class="control-group">
                <label>MA период:</label>
                <input type="number" id="ma-period-input" value="30" min="1" max="365" style="width:70px;">
            </div>

            <div class="control-group">
                <label>С:</label>
                <input type="date" id="date-from" class="date-input">
            </div>

            <div class="control-group">
                <label>По:</label>
                <input type="date" id="date-to" class="date-input">
            </div>

            <button class="control-btn" id="update-btn">🔄 Обновить</button>
            <button class="control-btn" id="reset-btn">↩ Сбросить</button>
            <button class="control-btn" id="fullscreen-btn">⛶ Полный экран</button>
        </div>

        <!-- Область графика -->
        <div class="chart-area">
            <div class="chart-container" id="chart-container"></div>
        </div>
        <div class="status info" id="status">Загрузка данных...</div>
    </div>

    <script>
        console.log('🔧 Frontend Configuration:', CONFIG);

        // Глобальные переменные
        let chart = null;
        let coinbaseSeries = null;
        let comparisonSeries = null;
        let currentComparison = 'btc';
        let currentTimeframe = '1W';
        let currentMaPeriod = 14;

        // Состояние данных
        let coinbaseData = [];
        let comparisonData = [];
        let isLoading = false;

        // Кэш данных и серий для инструментов
        const DATA_CACHE = {};   // ключ: `${instrument}_${tf}`  → массив свечей/линии
        const SERIES_CACHE = {}; // ключ: instrument → созданная серия

        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', function() {
            console.log('✅ TradingView Lightweight Charts loaded successfully');
            
            // Инициализация элементов управления
            initializeControls();
            
            // Инициализация графика
            initializeChart();
            
            // Загрузка данных
            loadData();
        });

        function initializeControls() {
            // Установка значений по умолчанию
            document.getElementById('ma-period-input').value = currentMaPeriod;

            // Обработчики событий
            document.getElementById('ma-period-input').addEventListener('change', function() {
                currentMaPeriod = Math.max(1, parseInt(this.value) || 30);
                loadData();
            });

            document.getElementById('update-btn').addEventListener('click', loadData);
            document.getElementById('reset-btn').addEventListener('click', resetChart);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);

            // Кнопки таймфреймов (имеют data-timeframe)
            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                const tf = btn.dataset.timeframe;
                if (!tf) return; // пропускаем кнопки без таймфрейма (например instrument)
                btn.addEventListener('click', () => {
                    currentTimeframe = tf;
                    updateTimeframeButtons();
                    loadData();
                });
            });

            // Кнопки инструментов
            document.querySelectorAll('.instrument-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentComparison = btn.dataset.instrument;
                    updateInstrumentButtons();
                    updateComparisonInfo();
                    updateTimeframeButtons();
                    loadData();
                });
            });

            // Даты будут выставлены после initial loadData (fitContent)
            updateComparisonInfo();
            updateTimeframeButtons();
            updateInstrumentButtons();
        }

        function initializeChart() {
            if (!window.LightweightCharts) {
                console.error('TradingView Lightweight Charts not loaded');
                return;
            }

            const chartContainer = document.getElementById('chart-container');
            
            chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight,
                layout: {
                    background: { color: '#0D1421' },
                    textColor: '#B2B5BE',
                },
                grid: {
                    vertLines: { color: '#2A2E39' },
                    horzLines: { color: '#2A2E39' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                leftPriceScale: {
                    visible: true,
                    invertScale: true,
                    borderColor: '#2A2E39',
                    scaleMargins: {
                        top: 0.05,
                        bottom: 0.05,
                    },
                },
                rightPriceScale: {
                    borderColor: '#2A2E39',
                    scaleMargins: {
                        top: 0.05,
                        bottom: 0.05,
                    },
                },
                timeScale: {
                    borderColor: '#2A2E39',
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            // Создание серий данных
            coinbaseSeries = chart.addLineSeries({
                color: '#2962FF',
                lineWidth: 3,
                priceScaleId: 'left',
                title: 'Coinbase MA' + currentMaPeriod,
                crosshairMarkerVisible: true,
                crosshairMarkerRadius: 6,
                crosshairMarkerBorderColor: '#2962FF',
                crosshairMarkerBackgroundColor: '#2962FF',
            });

            comparisonSeries = chart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350'
            });

            // Надёжный ресайз через ResizeObserver (ловит любые изменения контейнера)
            if (window.ResizeObserver) {
                const ro = new ResizeObserver(entries => {
                    for (const e of entries) {
                        const { width, height } = e.contentRect;
                        if (typeof chart.resize === 'function') {
                            chart.resize(width, height); // v4+
                        } else {
                            chart.applyOptions({ width, height }); // v3 fallback
                        }
                    }
                });
                ro.observe(chartContainer);
            } else {
                // fallback на событие window.resize для старых браузеров
                window.addEventListener('resize', () => {
                    const w = chartContainer.clientWidth;
                    const h = chartContainer.clientHeight;
                    if (typeof chart.resize === 'function') chart.resize(w, h);
                    else chart.applyOptions({ width: w, height: h });
                });
            }

            console.log('✅ Chart initialized successfully');
        }

        function updateComparisonInfo() {
            const instrument = CONFIG.INSTRUMENTS[currentComparison];
            if (instrument) {
                const cmpEl = document.getElementById('comparison-symbol');
                if (cmpEl) cmpEl.textContent = instrument.name;
                if (comparisonSeries) {
                    comparisonSeries.applyOptions({
                        color: instrument.color,
                        title: instrument.name,
                        crosshairMarkerBorderColor: instrument.color,
                        crosshairMarkerBackgroundColor: instrument.color,
                    });
                }
            }
        }

        function setStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        async function loadData() {
            if (isLoading) return;
            isLoading = true;

            try {
                setStatus('Загрузка данных...', 'info');
                
                // Загрузка Coinbase данных
                await loadCoinbaseData();
                
                // Загрузка данных для сравнения
                await loadComparisonData();
                
                // Синхронизируем начало/конец по пересечению временных рядов
                if (chart && coinbaseData.length && comparisonData.length) {
                    const start = Math.max(coinbaseData[0].time, comparisonData[0].time);
                    const end   = Math.min(coinbaseData[coinbaseData.length - 1].time,
                                        comparisonData[comparisonData.length - 1].time);
                    chart.timeScale().setVisibleRange({ from: start, to: end });
                } else if (chart) {
                    chart.timeScale().fitContent();
                }

                // Обновляем поля дат полным диапазоном
                if (coinbaseData.length > 0) {
                    const firstDateStr = new Date(coinbaseData[0].time * 1000).toISOString().split('T')[0];
                    const lastDateStr = new Date(coinbaseData[coinbaseData.length - 1].time * 1000).toISOString().split('T')[0];
                    document.getElementById('date-from').value = firstDateStr;
                    document.getElementById('date-to').value = lastDateStr;
                }

                setStatus('Данные загружены успешно', 'success');
                
            } catch (error) {
                console.error('Error loading data:', error);
                setStatus('Ошибка загрузки данных: ' + error.message, 'error');
            } finally {
                isLoading = false;
            }
        }

        async function loadCoinbaseData() {
            try {
                const response = await fetch('/data/data.json');
                const data = await response.json();
                
                // Обработка данных в зависимости от формата
                let processedData = [];
                if (data.data && Array.isArray(data.data)) {
                    processedData = data.data.map(item => ({
                        time: Math.floor(new Date(item.date).getTime() / 1000),
                        value: parseFloat(item.rank)
                    }));
                } else {
                    // Старый формат
                    processedData = Object.entries(data).map(([date, values]) => ({
                        time: Math.floor(new Date(date).getTime() / 1000),
                        value: parseFloat(values.Overall || 0)
                    }));
                }

                // Сортировка по времени
                processedData.sort((a, b) => a.time - b.time);

                // Применение скользящей средней
                const maData = applyMovingAverage(processedData, currentMaPeriod);
                
                // агрегируем если нужно
                const displayData = aggregateData(maData, currentTimeframe);
                coinbaseData = displayData;
                if (coinbaseSeries) {
                    coinbaseSeries.setData(displayData);
                    coinbaseSeries.applyOptions({
                        title: 'Coinbase MA' + currentMaPeriod,
                    });
                }

                // Обновление информации в хедере
                if (displayData.length > 0) {
                    const latestRank = displayData[displayData.length - 1].value;
                    const rankEl = document.getElementById('rank-value');
                    if (rankEl) rankEl.textContent = latestRank.toFixed(0);
                }

                console.log(`✅ Coinbase data loaded: ${displayData.length} points`);
                
            } catch (error) {
                console.error('Error loading Coinbase data:', error);
                throw error;
            }
        }

        async function loadComparisonData() {
            const instrument = CONFIG.INSTRUMENTS[currentComparison];
            if (!instrument) return;

            // Скрываем все созданные ранее серии
            Object.values(SERIES_CACHE).forEach(s => s.applyOptions({ visible: false }));

            // Получаем / создаём серию для текущего инструмента
            if (!SERIES_CACHE[currentComparison]) {
                SERIES_CACHE[currentComparison] = instrument.seriesType === 'line'
                    ? chart.addLineSeries({
                        color: instrument.color,
                        priceScaleId: 'right',
                        lineWidth: 2,
                    })
                    : chart.addCandlestickSeries({
                        upColor: '#26a69a',
                        downColor: '#ef5350',
                        borderVisible: false,
                        wickUpColor: '#26a69a',
                        wickDownColor: '#ef5350',
                        priceScaleId: 'right',
                    });
            }
            comparisonSeries = SERIES_CACHE[currentComparison];
            comparisonSeries.applyOptions({ visible: true });

            // Ключ кэша данных учитывает таймфрейм, т.к. при 1D/1W разные массивы
            const dataKey = `${currentComparison}_${currentTimeframe}`;

            if (DATA_CACHE[dataKey]) {
                comparisonSeries.setData(DATA_CACHE[dataKey]);
            } else {
                try {
                    if (instrument.dataSource === 'api') {
                        await loadApiData(instrument);
                    } else {
                        await loadFileData(instrument);
                    }
                    // Сохраняем копию текущих данных в кэш
                    DATA_CACHE[dataKey] = comparisonData;
                } catch (error) {
                    console.error('Error loading comparison data:', error);
                    throw error;
                }
            }

            // Автомасштаб по времени (цена масштабируется автоматически)
            if (chart) chart.timeScale().fitContent();

            // Устанавливаем видимый диапазон времени: не раньше начала Coinbase
            if (coinbaseData.length && comparisonData.length && chart) {
                const start = Math.max(coinbaseData[0].time, comparisonData[0].time);
                const end = comparisonData[comparisonData.length - 1].time;
                chart.timeScale().setVisibleRange({ from: start, to: end });
            }
        }

        async function loadApiData(instrument) {
            try {
                const response = await fetch(`/api/history?symbol=${instrument.apiSymbol}&resolution=${currentTimeframe}&from=1&to=${Math.floor(Date.now() / 1000)}`);
                const data = await response.json();
                
                if (data.s === 'ok' && data.t && data.c) {
                    const processedData = data.t.map((time, index) => ({
                        time: time,
                        open: parseFloat(data.o[index]),
                        high: parseFloat(data.h[index]),
                        low: parseFloat(data.l[index]),
                        close: parseFloat(data.c[index])
                    }));

                    // агрегируем если нужно
                    const displayData = aggregateCandleData(processedData, currentTimeframe);
                    comparisonData = displayData;
                    if (comparisonSeries) {
                        comparisonSeries.setData(displayData);
                    }

                    // Обновление информации в хедере
                    if (displayData.length > 0) {
                        const latestValue = displayData[displayData.length - 1].value;
                        const btcEl = document.getElementById('btc-value');
                        if (btcEl) btcEl.textContent = '$' + latestValue.toLocaleString();
                    }

                    console.log(`✅ ${instrument.name} data loaded: ${displayData.length} points`);
                } else if (data.s === 'no_data') {
                    console.error(`Coinglass API: no data for ${instrument.apiSymbol}`, data);
                    if (comparisonSeries) {
                        comparisonSeries.setData([]);
                    }
                    return;
                } else {
                    console.error('Coinglass API: unexpected response', data);
                    throw new Error('Invalid API response');
                }
                
            } catch (error) {
                console.error(`Error loading ${instrument.name} API data:`, error);
                throw error;
            }
        }

        async function loadFileData(instrument) {
            try {
                // Определяем файл согласно текущему таймфрейму
                const tfMap = { '4h': '1D', '1D': '1D', '3D': '1D', '1W': '1W' };
                const tfFile = tfMap[currentTimeframe] || '1D';

                // Формируем URL. В CONFIG для csv-инструментов указан path '/data/vix/' и т.д.
                const basePath = instrument.path; // заканчивается слэшем
                // Если указан шаблон — используем его, иначе формируем по symbol или ключу
                const fileName = instrument.filePattern
                    ? instrument.filePattern.replace('{tf}', tfFile)
                    : `${(instrument.symbol || currentComparison).toUpperCase()}, ${tfFile}.csv`;
                const url = `${basePath}${fileName}`;

                const resp = await fetch(url);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const text = await resp.text();

                const lines = text.trim().split(/\r?\n/).slice(1); // skip header
                const raw = lines.map(line => line.split(',')).filter(arr => arr.length >= 5);

                const parsed = raw.map(arr => {
                    const tsNum = Number(arr[0]);
                    // Если в файле epoch seconds, оставляем; если миллисекунды, делим
                    const epochSec = tsNum > 1e12 ? Math.floor(tsNum / 1000) : tsNum;
                    return {
                        time: epochSec,
                        open: parseFloat(arr[1]),
                        high: parseFloat(arr[2]),
                        low:  parseFloat(arr[3]),
                        close:parseFloat(arr[4])
                    };
                });

                let displayData = [];
                const isDailyFile = tfFile === '1D';
                const needsAggregation = (currentTimeframe === '3D') || (currentTimeframe === '1W' && isDailyFile);

                if (instrument.seriesType === 'line') {
                    const lineData = parsed.map(p => ({ time: p.time, value: p.close }));
                    displayData = needsAggregation ? aggregateData(lineData, currentTimeframe) : lineData;
                    if (comparisonSeries) comparisonSeries.setData(displayData);
                    console.log(`✅ CSV data loaded for ${instrument.name}: ${displayData.length} points`);
                } else {
                    displayData = needsAggregation ? aggregateCandleData(parsed, currentTimeframe) : parsed;
                    if (comparisonSeries) comparisonSeries.setData(displayData);
                    console.log(`✅ CSV data loaded for ${instrument.name}: ${displayData.length} candles`);
                }
                comparisonData = displayData;
            } catch (e) {
                console.error(`Error loading CSV for ${instrument.name}:`, e);
            }
        }

        function applyMovingAverage(data, period) {
            if (data.length < period) return data;
            
            const result = [];
            for (let i = period - 1; i < data.length; i++) {
                let sum = 0;
                for (let j = 0; j < period; j++) {
                    sum += data[i - j].value;
                }
                result.push({
                    time: data[i].time,
                    value: sum / period
                });
            }
            return result;
        }

        function resetChart() {
            currentComparison = 'btc';
            currentTimeframe = '1W';
            currentMaPeriod = 14;
            
            document.getElementById('ma-period-input').value = currentMaPeriod;
            
            updateComparisonInfo();
            updateTimeframeButtons();
            loadData();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // Обработчик изменения полноэкранного режима
        document.addEventListener('fullscreenchange', () => {
            // переключаем CSS-класс
            const isFs = !!document.fullscreenElement;
            document.body.classList.toggle('fullscreen-mode', isFs);

            if (!chart) return;
            // Двойной rAF даёт браузеру 2 кадра на перерасчёт layout,
            // иначе высота может быть вычислена некорректно сразу после выхода
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const container = document.getElementById('chart-container');
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (typeof chart.resize === 'function') {
                        chart.resize(w, h);
                    } else {
                        chart.applyOptions({ width: w, height: h });
                    }
                    chart.timeScale().fitContent();
                    // контрольный resize спустя 300ms – гарантирует подгонку после полного layout
                    setTimeout(() => {
                        window.dispatchEvent(new Event('resize'));
                    }, 300);
                });
            });
        });

        const TF_MAP = { '4h': '240', '1D': 'D', '3D': '3D', '1W': 'W' };

        function updateTimeframeButtons() {
            const supported = CONFIG.INSTRUMENTS[currentComparison]?.supportedTimeframes || [];

            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                const tf = btn.dataset.timeframe;
                if (!tf) return;
                const code = TF_MAP[tf] || tf;
                const isSupported = supported.includes(code);

                btn.classList.toggle('disabled', !isSupported);
                btn.classList.toggle('active', isSupported && tf === currentTimeframe);
            });

            // если текущий timeframe не поддерживается – переключаемся на первый доступный
            if (!supported.includes(TF_MAP[currentTimeframe] || currentTimeframe)) {
                if (supported.length) {
                    const fallback = supported[0];
                    // обратное отображение
                    const reverseMap = { '240': '4h', 'D': '1D', '3D': '3D', 'W': '1W' };
                    currentTimeframe = reverseMap[fallback] || '1D';
                }
            }
        }

        function updateInstrumentButtons() {
            document.querySelectorAll('.instrument-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.instrument === currentComparison);
            });
        }

        // Агрегация дневных данных в 3-дневные или недельные свечи
        function aggregateData(data, timeframe) {
            if (!Array.isArray(data) || data.length === 0) return data;

            const stepMap = { '3D': 3, '1W': 7 };
            const step = stepMap[timeframe] || 1;
            if (step === 1) return data;

            const result = [];
            for (let i = 0; i < data.length; i += step) {
                const slice = data.slice(i, i + step);
                if (!slice.length) continue;
                // усредняем значения; можно заменить на close последнего
                const avg = slice.reduce((sum, p) => sum + p.value, 0) / slice.length;
                result.push({ time: slice[slice.length - 1].time, value: avg });
            }
            return result;
        }

        // агрегируем свечи
        function aggregateCandleData(data, timeframe) {
            const stepMap = { '3D': 3, '1W': 7 };
            const step = stepMap[timeframe] || 1;
            if (step === 1) return data;
            const out = [];
            for (let i = 0; i < data.length; i += step) {
                const slice = data.slice(i, i + step);
                if (!slice.length) continue;
                out.push({
                    time: slice[slice.length - 1].time,
                    open: slice[0].open,
                    close: slice[slice.length - 1].close,
                    high: Math.max(...slice.map(s => s.high)),
                    low: Math.min(...slice.map(s => s.low))
                });
            }
            return out;
        }
    </script>
</body>
</html> 