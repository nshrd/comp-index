<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CBMA14 Chart - TradingView Style</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <script src="config.js"></script>
    <script src="optimized_utils.js"></script>
    <script src="enhanced_technical_indicators.js"></script>
    <script src="indicators_manager.js"></script>
    <script src="timescale_integration.js"></script>
    <script src="advanced_chart_features.js"></script>
    <script src="datafeed_optimization.js"></script>
    <script src="events_and_export.js"></script>
    <script src="advanced_series_and_scale.js"></script>
    <script src="mobile_responsive.js"></script>
    <script src="candlestick_bar_series.js"></script>
    <script src="advanced_time_features.js"></script>
    <!-- <script src="performance_optimizations.js"></script> -->
    <script src="animation_effects.js"></script>
    <script src="custom_crosshair.js"></script>
    <style>
        /* ========= ОСНОВНЫЕ СТИЛИ TRADINGVIEW ========= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", sans-serif;
            background: #0D1421;
            color: #B2B5BE;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* ========= БОКОВАЯ ПАНЕЛЬ СЛЕВА ========= */
        .sidebar {
            width: 48px;
            background: #1E222D;
            border-right: 1px solid #2A2E39;
            display: flex;
            flex-direction: column;
            padding: 8px 0;
        }

        .sidebar-tool {
            width: 32px;
            height: 32px;
            margin: 4px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: transparent;
        }

        .sidebar-tool:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar-tool.active {
            background: #2962FF;
            color: white;
        }

        /* ========= ОСНОВНОЙ КОНТЕНТ ========= */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0D1421;
        }

        /* ========= ВЕРХНЯЯ ПАНЕЛЬ ========= */
        .top-panel {
            height: 48px;
            background: #1E222D;
            border-bottom: 1px solid #2A2E39;
            display: flex;
            align-items: center;
            padding: 0 16px;
            justify-content: space-between;
        }

        .symbol-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .symbol-name {
            font-size: 16px;
            font-weight: 600;
            color: #FFFFFF;
        }

        .symbol-details {
            font-size: 11px;
            color: #787B86;
        }

        .price-data {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .price-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .price-label {
            font-size: 10px;
            font-weight: 500;
        }

        .price-value {
            font-size: 14px;
            font-weight: 600;
            color: #FFFFFF;
        }

        .price-change {
            font-size: 12px;
            font-weight: 500;
        }

        .price-change.positive {
            color: #00C851;
        }

        .price-change.negative {
            color: #FF4444;
        }

        /* ========= ПАНЕЛЬ ТАЙМФРЕЙМОВ ========= */
        .toolbar-panel {
            height: 40px;
            background: #1E222D;
            border-bottom: 1px solid #2A2E39;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        .toolbar-group {
            display: flex;
            gap: 2px;
        }

        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            color: #B2B5BE;
            background: transparent;
            border: none;
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #FFFFFF;
        }

        .toolbar-btn.active {
            background: #2962FF;
            color: #FFFFFF;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: #2A2E39;
        }

        /* ========= ПАНЕЛЬ УПРАВЛЕНИЯ ========= */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px 16px;
            background: #1E222D;
            border-bottom: 1px solid #2A2E39;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #2A2E39;
            border-radius: 6px;
            font-size: 12px;
        }

        .control-group label {
            color: #B2B5BE;
            font-weight: 500;
            white-space: nowrap;
        }

        .control-group select,
        .control-group input {
            background: #131722;
            border: 1px solid #2A2E39;
            border-radius: 4px;
            padding: 4px 8px;
            color: #FFFFFF;
            font-size: 12px;
            min-width: 80px;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #2962FF;
            box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.3);
        }

        .control-btn {
            background: #2962FF;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #1E53E5;
            transform: translateY(-1px);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .date-input {
            width: 140px !important;
        }

        /* ========= ОБЛАСТЬ ГРАФИКА ========= */
        .chart-area {
            flex: 1;
            position: relative;
            background: #0D1421;
        }

        .chart-container {
            width: 100%;
            height: 100%;
            background: #0D1421;
        }

        .status {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            padding: 8px 12px;
            background: rgba(30, 34, 45, 0.9);
            border: 1px solid #2A2E39;
            border-radius: 6px;
            font-size: 12px;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        .status.success {
            border-color: #00C851;
            color: #00C851;
        }

        .status.error {
            border-color: #FF4444;
            color: #FF4444;
        }

        .status.info {
            border-color: #2962FF;
            color: #2962FF;
        }

        /* ========= ПРАВАЯ ПАНЕЛЬ ========= */
        .right-panel {
            width: 280px;
            background: #1E222D;
            border-left: 1px solid #2A2E39;
            display: flex;
            flex-direction: column;
        }

        .right-panel-header {
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 600;
            color: #FFFFFF;
            border-bottom: 1px solid #2A2E39;
            background: rgba(41, 98, 255, 0.1);
        }

        .watchlist {
            flex: 1;
            overflow-y: auto;
        }

        .watchlist-header {
            padding: 8px 12px;
            font-size: 11px;
            color: #787B86;
            border-bottom: 1px solid #2A2E39;
        }

        .watchlist-item {
            padding: 12px 16px;
            border-bottom: 1px solid #2A2E39;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .watchlist-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .watchlist-item.active {
            background: rgba(41, 98, 255, 0.2);
            border-left: 3px solid #2962FF;
        }

        .watchlist-symbol {
            font-size: 13px;
            font-weight: 500;
            color: #FFFFFF;
            margin-bottom: 4px;
        }

        .watchlist-price {
            font-size: 11px;
            color: #B2B5BE;
        }

        .watchlist-change {
            font-size: 11px;
            font-weight: 500;
        }

        .watchlist-change.positive {
            color: #00C851;
        }

        .watchlist-change.negative {
            color: #FF4444;
        }

        /* ========= СКРЫТЫЕ ЭЛЕМЕНТЫ ========= */
        .hidden {
            display: none;
        }

        /* ========= АДАПТИВНОСТЬ ========= */
        @media (max-width: 1200px) {
            .right-panel {
                width: 240px;
            }
            
            .price-data {
                gap: 12px;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 48px;
                flex-direction: row;
                justify-content: center;
                border-right: none;
                border-bottom: 1px solid #2A2E39;
            }
            
            .right-panel {
                display: none;
            }
            
            .controls {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }
            
            .control-group {
                justify-content: space-between;
            }
            
            .top-panel {
                flex-direction: column;
                height: auto;
                padding: 8px 16px;
                gap: 8px;
            }
            
            .price-data {
                justify-content: space-around;
                width: 100%;
            }
        }

        /* ========= АНИМАЦИИ ========= */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        /* ========= ДОПОЛНИТЕЛЬНЫЕ УЛУЧШЕНИЯ ========= */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1E222D;
        }

        ::-webkit-scrollbar-thumb {
            background: #2A2E39;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #363A45;
        }

        select option {
            background: #1E222D;
            color: #FFFFFF;
        }

        /* ========= FULLSCREEN MODE ========= */
        .fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            background: #0D1421;
        }

        .fullscreen .sidebar,
        .fullscreen .right-panel {
            display: none;
        }

        .fullscreen .main-content {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Боковая панель инструментов -->
        <div class="sidebar">
            <div class="sidebar-tool active" id="sidebar-chart" title="График">
                📊
            </div>
            <div class="sidebar-tool" id="sidebar-indicators" title="Индикаторы">
                📈
            </div>
            <div class="sidebar-tool" id="sidebar-drawing" title="Рисование">
                ✏️
            </div>
            <div class="sidebar-tool" id="sidebar-alerts" title="Оповещения">
                🔔
            </div>
            <div class="sidebar-tool" id="sidebar-settings" title="Настройки">
                ⚙️
            </div>
        </div>
        
        <!-- Основная область -->
        <div class="main-content">
            <!-- Верхняя панель с символом и данными -->
            <div class="top-panel">
                <div class="symbol-info">
                    <div class="symbol-name">Coinbase Index Rank</div>
                    <div class="symbol-details">Основная кривая • vs <span id="comparison-instrument">BTC</span> • 1W • charts.expert</div>
                </div>
                <div class="price-data">
                    <div class="price-item">
                        <span class="price-label" style="color: #2962FF;">Rank</span>
                        <span class="price-value" id="coinbase-rank">-</span>
                    </div>
                    <div class="price-item">
                        <span class="price-label" style="color: #F7931A;" id="comparison-label">BTC</span>
                        <span class="price-value" id="comparison-price">-</span>
                    </div>
                    <div class="price-item">
                        <span class="price-change" id="rank-change">+0.00%</span>
                    </div>
                    <div class="price-item">
                        <span class="price-change" id="comparison-change">+0.00%</span>
                    </div>
                </div>
            </div>
            
            <!-- Панель инструментов -->
            <div class="toolbar-panel">
                <div class="toolbar-group">
                    <div class="toolbar-btn active">1s</div>
                    <div class="toolbar-btn">1m</div>
                    <div class="toolbar-btn">5m</div>
                    <div class="toolbar-btn">15m</div>
                    <div class="toolbar-btn">30m</div>
                    <div class="toolbar-btn">1h</div>
                    <div class="toolbar-btn">4h</div>
                    <div class="toolbar-btn">1D</div>
                    <div class="toolbar-btn">1W</div>
                    <div class="toolbar-btn">1M</div>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <div class="toolbar-btn">📊</div>
                    <div class="toolbar-btn">📈</div>
                    <div class="toolbar-btn">📉</div>
                    <div class="toolbar-btn">⚡</div>
                </div>
            </div>
            
            <!-- Элементы управления -->
            <div class="controls">
                <div class="control-group" style="background: rgba(41, 98, 255, 0.1); border-color: #2962FF;">
                    <label style="color: #2962FF; font-weight: 600;">📊 Coinbase Index:</label>
                    <span style="color: #FFFFFF; font-size: 11px;">Основная кривая (всегда показана)</span>
                </div>
                
                <div class="control-group">
                    <label for="comparisonSelect">🎯 Сравнить с:</label>
                    <select id="comparisonSelect">
                        <option value="btc" selected>🟠 BTC</option>
                        <option value="spx">🔵 S&P 500</option>
                        <option value="vix">🔴 VIX</option>
                        <option value="dxy">🟢 DXY</option>
                        <option value="total3esbtc">🟡 Total3-BTC</option>
                        <option value="withoutbtceth">🟣 Without BTC/ETH</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="timeframeSelect">Таймфрейм:</label>
                    <select id="timeframeSelect">
                        <option value="240">4H</option>
                        <option value="D">1D</option>
                        <option value="3D">3D</option>
                        <option value="W" selected>1W</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="maPeriodSelect">MA период:</label>
                    <select id="maPeriodSelect">
                        <option value="7">7</option>
                        <option value="14" selected>14</option>
                        <option value="21">21</option>
                        <option value="50">50</option>
                        <option value="200">200</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="fromDate">С:</label>
                    <input type="date" id="fromDate" class="date-input">
                </div>
                
                <div class="control-group">
                    <label for="toDate">По:</label>
                    <input type="date" id="toDate" class="date-input">
                </div>
                
                <button id="resetScale" class="control-btn">🔄 Сбросить</button>
                <button id="fitContent" class="control-btn">📏 Подогнать</button>
                <button id="toggleFullscreen" class="control-btn">⛶ Полный экран</button>
            </div>
            
            <!-- Область графика -->
            <div class="chart-area">
                <div class="chart-container" id="chart-container"></div>
                <div class="status" id="status">Загрузка графиков...</div>
            </div>
        </div>
        
        <!-- Правая панель -->
        <div class="right-panel">
            <div class="right-panel-header">📊 Coinbase Index vs:</div>
            <div class="watchlist">
                <div class="watchlist-header" style="padding: 8px 12px; font-size: 11px; color: #787b86; border-bottom: 1px solid #2a2e39;">
                    Выберите инструмент для сравнения
                </div>
                <div class="watchlist-item active" data-symbol="btc">
                    <div>
                        <div class="watchlist-symbol">🟠 BTC</div>
                        <div class="watchlist-price">$108,082</div>
                    </div>
                    <div class="watchlist-change positive">+0.05%</div>
                </div>
                <div class="watchlist-item" data-symbol="spx">
                    <div>
                        <div class="watchlist-symbol">🔵 S&P 500</div>
                        <div class="watchlist-price">5,974</div>
                    </div>
                    <div class="watchlist-change negative">-0.32%</div>
                </div>
                <div class="watchlist-item" data-symbol="vix">
                    <div>
                        <div class="watchlist-symbol">🔴 VIX</div>
                        <div class="watchlist-price">14.2</div>
                    </div>
                    <div class="watchlist-change positive">+2.1%</div>
                </div>
                <div class="watchlist-item" data-symbol="dxy">
                    <div>
                        <div class="watchlist-symbol">🟢 DXY</div>
                        <div class="watchlist-price">105.8</div>
                    </div>
                    <div class="watchlist-change negative">-0.1%</div>
                </div>
                <div class="watchlist-item" data-symbol="total3esbtc">
                    <div>
                        <div class="watchlist-symbol">🟡 Total3-BTC</div>
                        <div class="watchlist-price">0.0142</div>
                    </div>
                    <div class="watchlist-change positive">+1.5%</div>
                </div>
                <div class="watchlist-item" data-symbol="withoutbtceth">
                    <div>
                        <div class="watchlist-symbol">🟣 Without BTC/ETH</div>
                        <div class="watchlist-price">0.0089</div>
                    </div>
                    <div class="watchlist-change negative">-0.8%</div>
                </div>
            </div>
            <div style="padding: 8px 12px; font-size: 10px; color: #787b86; border-top: 1px solid #2a2e39; line-height: 1.4;">
                💡 Синяя кривая (слева) - ранг Coinbase Index<br>
                🎯 Цветная кривая (справа) - выбранный инструмент
            </div>
        </div>
    </div>

    <!-- Скрытые элементы для индикаторов -->
    <div class="hidden">
        <select id="indicatorSelect">
            <option value="">Выберите индикатор</option>
            <option value="sma">SMA</option>
            <option value="ema">EMA</option>
            <option value="rsi">RSI</option>
            <option value="macd">MACD</option>
            <option value="bollinger">Bollinger Bands</option>
            <option value="stochastic">Stochastic</option>
            <option value="cbma14">CBMA14 Enhanced</option>
        </select>
        <button id="addIndicator">Добавить</button>
        <select id="quickTimeRange">
            <option value="">Выбрать диапазон</option>
            <option value="7days">7 дней</option>
            <option value="30days">30 дней</option>
            <option value="3months">3 месяца</option>
            <option value="6months">6 месяцев</option>
            <option value="1year">1 год</option>
            <option value="2years">2 года</option>
            <option value="all">Все данные</option>
        </select>
        <select id="exportOptions">
            <option value="">Экспорт</option>
            <option value="png">PNG</option>
            <option value="svg">SVG</option>
            <option value="csv">CSV</option>
        </select>
        <select id="seriesOptions">
            <option value="">Добавить серию</option>
            <option value="line">Линия</option>
            <option value="area">Область</option>
            <option value="histogram">Гистограмма</option>
        </select>
        <select id="priceScaleMode">
            <option value="normal">Обычный</option>
            <option value="logarithmic">Логарифмический</option>
        </select>
        <button id="saveState">Сохранить</button>
        <button id="toggleTheme">Сменить тему</button>
        <button id="toggleGrid">Сетка</button>
        <select id="addPriceLevels">
            <option value="">Уровни цен</option>
            <option value="current">Текущая цена</option>
            <option value="support">Поддержка</option>
            <option value="resistance">Сопротивление</option>
        </select>
        <select id="candlestickOptions">
            <option value="">Добавить свечи</option>
            <option value="classic">Классические</option>
            <option value="hollow">Полые</option>
            <option value="heikin">Heikin-Ashi</option>
            <option value="bar">Бары</option>
        </select>
        <select id="timeFeatures">
            <option value="">Функции времени</option>
            <option value="business_hours">Торговые часы</option>
            <option value="timezone">Часовой пояс</option>
            <option value="goto_now">Текущее время</option>
            <option value="custom_marks">Пользовательские метки</option>
        </select>
        <select id="crosshairMode">
            <option value="normal">Обычный</option>
            <option value="magnet">Магнитный</option>
            <option value="hidden">Скрытый</option>
        </select>
        <select id="animationEffects">
            <option value="">Эффекты</option>
            <option value="entrance_fade">Появление</option>
            <option value="highlight">Подсветка</option>
            <option value="pulse">Пульсация</option>
            <option value="loading">Загрузка</option>
        </select>
        <button id="toggleAnimations">Анимации</button>
    </div>

    <script>
        // Конфигурация загружается из config.js
        // CONFIG доступен глобально

        // Даты определяются динамически из реальных файлов данных
        
        // Кеш для хранения информации о датах начала данных каждого инструмента
        const instrumentDateCache = new Map();
        
        // Утилиты для работы с датами
        const DateUtils = {
            toTimestamp: (date) => Math.floor(date.getTime() / 1000),
            fromTimestamp: (timestamp) => new Date(timestamp * 1000),
            toLocaleDateString: (timestamp, locale = 'ru-RU') => new Date(timestamp * 1000).toLocaleDateString(locale),
            getDaysSinceEpoch: (date) => Math.floor(date.getTime() / (24 * 60 * 60 * 1000))
        };
        
        // Утилиты для работы с таймфреймами
        const TimeframeUtils = {
            // Мапинг таймфреймов в суффиксы для файлов
            getFileSuffix: (timeframe) => {
                const mapping = { '240': '4H', 'D': '1D', '3D': '1D', 'W': '1W' };
                return mapping[timeframe] || '1D';
            },
            
            // Мапинг таймфреймов в отображаемый текст
            getDisplayText: (timeframe) => {
                const mapping = { '240': '4H', 'D': '1D', '3D': '3D', 'W': '1W' };
                return mapping[timeframe] || '1D';
            },
            
            // Проверка нужна ли агрегация из дневных данных
            needsAggregation: (timeframe) => ['3D', 'W'].includes(timeframe),
            
            // Определение API таймфрейма
            getApiTimeframe: (timeframe) => {
                return TimeframeUtils.needsAggregation(timeframe) ? 'D' : timeframe;
            }
        };
        
        // Утилиты для работы с обновлением данных
        const DataUpdateUtils = {
            // Обновить дату начала если нужно и перезагрузить данные
            async updateStartDateAndReload(reason = 'доступности данных') {
                const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
                const fromDateInput = document.getElementById('fromDate');
                const currentFromDate = fromDateInput.value;
                
                // Если текущая дата раньше общей даты, обновляем ее
                if (!currentFromDate || new Date(currentFromDate) < new Date(commonStartDate)) {
                    fromDateInput.value = commonStartDate;
                    fromDate = commonStartDate;
                    console.log(`📅 Updated start date to: ${commonStartDate}`);
                    updateStatus(`Дата начала скорректирована до ${DateUtils.toLocaleDateString(DateUtils.toTimestamp(new Date(commonStartDate)))} из-за ${reason}`, 'info');
                }
                
                console.log('🔄 Reloading data...');
                loadData();
            }
        };
        
        let chart = null;
        let candlestickSeries = null;
        let coinbaseLineSeries = null; // Всегда показываем Coinbase Index
        let comparisonLineSeries = null; // Серия для сравнения с другими инструментами
        let currentMAPeriod = CONFIG.DEFAULT_MA_PERIOD;
        let currentTimeframe = 'W'; // По умолчанию недельный таймфрейм
        let currentComparisonInstrument = 'btc'; // Инструмент для сравнения с Coinbase
        let fromDate = null;
        let toDate = null;

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', async function() {
            // Проверяем доступность CONFIG
            if (typeof CONFIG === 'undefined') {
                console.error('❌ CONFIG not loaded! Make sure config.js is loaded before this script.');
                updateStatus('Ошибка: файл конфигурации не загружен', 'error');
                return;
            }
            
            // Проверяем доступность INSTRUMENTS в конфигурации
            if (!CONFIG.INSTRUMENTS || Object.keys(CONFIG.INSTRUMENTS).length === 0) {
                console.error('❌ INSTRUMENTS not configured! Make sure CONFIG.INSTRUMENTS is defined.');
                updateStatus('Ошибка: инструменты не настроены в конфигурации', 'error');
                return;
            }
            
            // Ожидаем загрузки TradingView Lightweight Charts
            await waitForTradingViewCharts();
            
            // Проверяем, что выбранный по умолчанию инструмент для сравнения существует
            if (!CONFIG.INSTRUMENTS[currentComparisonInstrument]) {
                console.warn(`⚠️ Default comparison instrument '${currentComparisonInstrument}' not found, using first available instrument.`);
                currentComparisonInstrument = Object.keys(CONFIG.INSTRUMENTS).find(key => key !== 'coinbase') || 'btc';
                console.log(`📊 Switched to comparison instrument: ${currentComparisonInstrument}`);
            }
            
            // Синхронизируем селектор инструментов с текущим выбранным инструментом
            const comparisonSelect = document.getElementById('comparisonSelect');
            if (comparisonSelect) {
                comparisonSelect.value = currentComparisonInstrument;
            }
            
            // Обновляем селектор таймфреймов для выбранного инструмента
            updateTimeframeSelector(currentComparisonInstrument);
            
            await initializeDates();
            initializeChart();
            setupEventHandlers();
            // Небольшая задержка перед загрузкой данных
            setTimeout(loadData, 100);
        });

        // Функция ожидания загрузки TradingView Charts
        async function waitForTradingViewCharts() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50; // 5 секунд максимум
                
                const checkTradingView = () => {
                    attempts++;
                    
                    if (typeof LightweightCharts !== 'undefined') {
                        console.log('✅ TradingView Lightweight Charts loaded successfully');
                        resolve();
                        return;
                    }
                    
                    if (attempts >= maxAttempts) {
                        console.error('❌ TradingView Lightweight Charts failed to load');
                        updateStatus('Ошибка: библиотека TradingView не загрузилась', 'error');
                        reject(new Error('TradingView Charts timeout'));
                        return;
                    }
                    
                    // Проверяем каждые 100ms
                    setTimeout(checkTradingView, 100);
                };
                
                checkTradingView();
            });
        }

        async function initializeDates() {
            // Устанавливаем даты по умолчанию: исходя из общей доступности данных
            const today = new Date();
            
            // Определяем общую начальную дату для Coinbase и инструмента сравнения
            const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
            
            toDate = today.toISOString().split('T')[0];
            fromDate = commonStartDate;
            
            document.getElementById('fromDate').value = fromDate;
            document.getElementById('toDate').value = toDate;
            
            console.log(`📅 Default date range set based on common data availability: ${fromDate} to ${toDate}`);
            console.log(`ℹ️ Note: This is the latest start date among all data sources`);
            console.log(`🕐 Default timeframe: ${currentTimeframe} (Weekly)`);
        }

        // ========================================
        // РАСШИРЕННЫЕ ТЕХНИЧЕСКИЕ ИНДИКАТОРЫ
        // ========================================
        // Используем новую Enhanced Technical Indicators библиотеку
        
        function calculateMovingAverage(values, period, type = 'SMA') {
            // Преобразуем значения в формат для индикаторов
            const data = values.map((value, index) => ({
                time: index,
                close: value
            }));
            
            // Используем расширенную библиотеку с кэшированием
            switch (type.toUpperCase()) {
                case 'EMA':
                    return TechnicalIndicators.ema(data, period).map(item => item.value);
                case 'SMA':
                default:
                    return TechnicalIndicators.sma(data, period).map(item => item.value);
            }
        }

        function aggregateDataByTimeframe(data, timeframe) {
            // Используем встроенный TimeScale API вместо самописной агрегации
            if (window.timeScaleManager && window.timeScaleManager.isInitialized) {
                return window.timeScaleManager.autoAggregateDataByVisibleRange(data, {
                    maxDataPoints: 1000,
                    minDataPoints: 100
                });
            } else {
                // Fallback на современную агрегацию если TimeScale API недоступен
                return DataAggregator.aggregateTimeSeriesData(data, timeframe);
            }
        }



        // ================================================
        // УСТАРЕВШИЕ ФУНКЦИИ УДАЛЕНЫ И ЗАМЕНЕНЫ НА 
        // СОВРЕМЕННЫЕ ИЗ optimized_utils.js
        // ================================================
        // Все функции агрегации теперь в DataAggregator



        async function loadCSVData(filePath) {
            try {
                console.log(`🔍 Loading CSV data from: ${filePath}`);
                const response = await fetch(filePath);
                
                if (!response.ok) {
                    throw new Error(`Failed to load ${filePath}: ${response.status} ${response.statusText}`);
                }
                
                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                // Находим индексы нужных колонок
                const timeIdx = headers.findIndex(h => h.trim() === 'time');
                const closeIdx = headers.findIndex(h => h.trim() === 'close');
                
                if (timeIdx === -1 || closeIdx === -1) {
                    throw new Error('Required columns (time, close) not found in CSV');
                }
                
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = line.split(',');
                    if (values.length < headers.length) continue;
                    
                    const time = parseInt(values[timeIdx]);
                    const close = parseFloat(values[closeIdx]);
                    
                    if (isNaN(time) || isNaN(close)) continue;
                    
                    data.push({
                        time: time,
                        value: close
                    });
                }
                
                console.log(`📊 Loaded ${data.length} data points from CSV`);
                return data;
                
            } catch (error) {
                console.error('❌ Error loading CSV data:', error);
                return [];
            }
        }

        async function getInstrumentFirstDate(instrumentKey, timeframe) {
            const cacheKey = `${instrumentKey}_${timeframe}`;
            
            // Проверяем кеш
            if (instrumentDateCache.has(cacheKey)) {
                return instrumentDateCache.get(cacheKey);
            }
            
            try {
                const instrument = CONFIG.INSTRUMENTS[instrumentKey];
                if (!instrument) {
                    console.error(`❌ Unknown instrument: ${instrumentKey}`);
                    return null;
                }

                let firstTimestamp = null;
                
                if (instrument.dataSource === 'json') {
                    // Для JSON данных (Coinbase Index)
                    try {
                        const cacheBuster = Date.now();
                        const response = await fetch(`${instrument.path}?v=${cacheBuster}`, {
                            headers: {
                                'Accept': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const contentType = response.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                            throw new Error(`Expected JSON, got ${contentType}`);
                        }
                        
                        const jsonData = await response.json();
                        if (jsonData.data && jsonData.data.length > 0) {
                            // Находим первую валидную дату
                            for (const item of jsonData.data) {
                                if (item.date && item.rank != null) {
                                    const timestamp = parseDateString(item.date);
                                    if (timestamp) {
                                        firstTimestamp = timestamp;
                                        break;
                                    }
                                }
                            }
                        }
                    } catch (jsonError) {
                        console.error(`❌ Error loading JSON for ${instrumentKey}:`, jsonError.message);
                        return null;
                    }
                } else if (instrument.dataSource === 'csv') {
                    // Для CSV данных (для 3D используем 1D файлы)
                    const timeframeSuffix = TimeframeUtils.getFileSuffix(timeframe);
                    const possibleFiles = [
                        `${instrument.path}TVC_${instrumentKey.toUpperCase()}, ${timeframeSuffix}.csv`,
                        `${instrument.path}SP_${instrumentKey.toUpperCase()}, ${timeframeSuffix}.csv`,
                        `${instrument.path}${instrumentKey.toUpperCase()}, ${timeframeSuffix}.csv`
                    ];
                    
                    for (const filePath of possibleFiles) {
                        try {
                            const response = await fetch(filePath);
                            if (response.ok) {
                                const csvText = await response.text();
                                const lines = csvText.split('\n');
                                
                                if (lines.length > 1) {
                                    const headers = lines[0].split(',');
                                    const timeIdx = headers.findIndex(h => h.trim() === 'time');
                                    
                                    if (timeIdx !== -1) {
                                        const firstDataLine = lines[1].split(',');
                                        if (firstDataLine.length > timeIdx) {
                                            const time = parseInt(firstDataLine[timeIdx]);
                                            if (!isNaN(time)) {
                                                firstTimestamp = time;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            continue; // Пробуем следующий файл
                        }
                    }
                }
                
                // Сохраняем в кеш
                instrumentDateCache.set(cacheKey, firstTimestamp);
                
                if (firstTimestamp) {
                    console.log(`📅 First date for ${instrumentKey} (${timeframe}): ${DateUtils.toLocaleDateString(firstTimestamp)}`);
                }
                
                return firstTimestamp;
                
            } catch (error) {
                console.error(`❌ Error getting first date for ${instrumentKey}:`, error);
                return null;
            }
        }

        async function getCommonStartDate(comparisonInstrumentKey, timeframe) {
            try {
                console.log(`🔍 Calculating common start date for Coinbase vs ${comparisonInstrumentKey} (${timeframe})`);
                
                const dates = [];
                
                // 1. Дата начала Coinbase Index (всегда показывается)
                const coinbaseStartTime = await getInstrumentFirstDate('coinbase', timeframe);
                if (coinbaseStartTime) {
                    dates.push(coinbaseStartTime);
                    console.log(`📅 Coinbase start date: ${DateUtils.toLocaleDateString(coinbaseStartTime)}`);
                }
                
                // 2. Дата начала выбранного инструмента для сравнения
                const comparisonStartTime = await getInstrumentFirstDate(comparisonInstrumentKey, timeframe);
                if (comparisonStartTime) {
                    dates.push(comparisonStartTime);
                    console.log(`📅 ${comparisonInstrumentKey} start date: ${DateUtils.toLocaleDateString(comparisonStartTime)}`);
                }
                
                // Проверяем, что у нас есть хотя бы одна дата
                if (dates.length === 0) {
                    console.warn('⚠️ No valid start dates found, using default fallback');
                    return '2017-01-01'; // Универсальный fallback
                }
                
                // Берем самую позднюю дату (максимальную)
                const commonStartTime = Math.max(...dates);
                const commonStartDate = new Date(commonStartTime * 1000).toISOString().split('T')[0];
                
                console.log(`✅ Common start date: ${commonStartDate} (${DateUtils.toLocaleDateString(commonStartTime)})`);
                
                return commonStartDate;
                
            } catch (error) {
                console.error('❌ Error calculating common start date:', error);
                return '2017-01-01'; // Универсальный fallback
            }
        }

        async function loadCoinbaseData(fromTime, toTime) {
            try {
                // Загружаем данные Coinbase Index из JSON (ЕДИНСТВЕННЫЙ источник)
                console.log('📊 Loading Coinbase Index from data.json...');
                
                // Добавляем cache-busting параметр для принудительной перезагрузки
                const cacheBuster = Date.now();
                const response = await fetch(`/data/data.json?v=${cacheBuster}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Проверяем Content-Type перед парсингом
                const contentType = response.headers.get('content-type');
                console.log('📊 Response Content-Type:', contentType);
                
                if (!contentType || !contentType.includes('application/json')) {
                    const textResponse = await response.text();
                    console.error('❌ Expected JSON, got:', contentType);
                    console.error('❌ Response text (first 500 chars):', textResponse.substring(0, 500));
                    throw new Error(`Expected JSON, got ${contentType || 'unknown'}`);
                }
                
                const jsonData = await response.json();
                console.log('📊 JSON data loaded, title:', jsonData.title);
                
                if (!jsonData.data || !Array.isArray(jsonData.data)) {
                    throw new Error('Invalid Coinbase data structure in JSON');
                }

                // Преобразуем JSON данные в формат для графика
                const allData = [];
                for (const item of jsonData.data) {
                    if (!item.date || item.rank == null) continue;

                    const timestamp = parseDateString(item.date);
                    if (!timestamp) continue;

                    allData.push({
                        time: timestamp,
                        value: parseFloat(item.rank),
                    });
                }

                if (allData.length === 0) {
                    throw new Error('No valid Coinbase data found in JSON');
                }
                
                // Сортируем по времени
                allData.sort((a, b) => a.time - b.time);
                console.log(`📊 Loaded ${allData.length} Coinbase data points from JSON`);

                // Вычисляем Moving Average с помощью TradingView Lightweight Charts
                const rawValues = allData.map(item => item.value);
                const maValues = calculateMovingAverage(rawValues, currentMAPeriod);

                // Создаем финальные данные с MA для отображения поверх графика
                const finalData = [];
                for (let i = 0; i < maValues.length; i++) {
                    const originalIndex = i + currentMAPeriod - 1;
                    if (originalIndex < allData.length) {
                        finalData.push({
                            time: allData[originalIndex].time,
                            value: maValues[i]
                        });
                    }
                }

                console.log(`📊 Coinbase MA${currentMAPeriod} ready: ${finalData.length} points`);

                // Фильтруем по временному диапазону
                const filteredData = finalData.filter(item => 
                    item.time >= fromTime && item.time <= toTime
                );

                console.log(`📊 Filtered Coinbase MA: ${filteredData.length} points`);

                // Устанавливаем данные в серию (MA поверх основных данных)
                if (coinbaseLineSeries && filteredData.length > 0) {
                    coinbaseLineSeries.setData(filteredData);
                    console.log('✅ Coinbase MA data set to series (overlay)');
                } else {
                    console.warn('⚠️ Coinbase series not initialized or no data');
                }

            } catch (error) {
                console.error('❌ Error loading Coinbase data:', error);
                updateStatus(`Ошибка загрузки Coinbase Index: ${error.message}`, 'error');
                // НЕ используем fallback - данные должны быть только из JSON!
            }
        }

        async function loadComparisonInstrumentData(fromTime, toTime) {
            try {
                const instrument = CONFIG.INSTRUMENTS[currentComparisonInstrument];
                if (!instrument) {
                    console.error(`❌ Unknown comparison instrument: ${currentComparisonInstrument}`);
                    return;
                }

                let data = [];

                if (instrument.dataSource === 'api') {
                    // Загружаем данные через API (для BTC)
                    data = await loadAPIData(instrument, fromTime, toTime);
                } else if (instrument.dataSource === 'csv') {
                    // Загружаем данные из CSV файлов
                    data = await loadInstrumentCSVData(instrument);
                    
                    // Фильтруем по датам
                    if (data.length > 0) {
                        data = data.filter(item => item.time >= fromTime && item.time <= toTime);
                    }
                }

                if (data.length === 0) {
                    console.warn(`⚠️ No data loaded for ${instrument.name}`);
                    return;
                }

                // Устанавливаем данные в соответствующую серию
                if (instrument.seriesType === 'candlestick' && candlestickSeries) {
                    candlestickSeries.setData(data);
                } else if (comparisonLineSeries) {
                    comparisonLineSeries.setData(data);
                }

                console.log(`✅ ${instrument.name} data loaded: ${data.length} points`);

            } catch (error) {
                console.error('❌ Error loading comparison instrument data:', error);
            }
        }

        async function loadAPIData(instrument, fromTime, toTime) {
            try {
                // Определяем API таймфрейм (API поддерживает только >= 4H)
                const apiTimeframe = TimeframeUtils.getApiTimeframe(currentTimeframe);
                
                if (TimeframeUtils.needsAggregation(currentTimeframe)) {
                    console.log(`📊 Loading 1D API data for ${currentTimeframe} timeframe (will be aggregated locally)`);
                }
                
                const apiUrl = `${CONFIG.API_BASE_URL}/history?symbol=${instrument.apiSymbol}&resolution=${apiTimeframe}&from=${fromTime}&to=${toTime}`;
                console.log(`🔗 API URL: ${apiUrl}`);
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const apiData = await response.json();
                
                console.log('📊 API Response:', apiData);
                console.log('📊 API Response status:', apiData.s);
                console.log('📊 API Response data keys:', Object.keys(apiData));

                if (apiData.s === 'ok' && apiData.t && apiData.o && apiData.h && apiData.l && apiData.c) {
                    console.log(`📊 API returned ${apiData.t.length} candles for ${instrument.apiSymbol}`);
                    
                    let candleData = [];
                    for (let i = 0; i < apiData.t.length; i++) {
                        if (apiData.t[i] && apiData.o[i] != null && apiData.h[i] != null && 
                            apiData.l[i] != null && apiData.c[i] != null) {
                            candleData.push({
                                time: apiData.t[i],
                                open: parseFloat(apiData.o[i]),
                                high: parseFloat(apiData.h[i]),
                                low: parseFloat(apiData.l[i]),
                                close: parseFloat(apiData.c[i]),
                            });
                        }
                    }

                    console.log(`📊 Processed ${candleData.length} valid candles`);

                    // Агрегируем данные если нужно используя современные утилиты
                    if (currentTimeframe === 'W' && apiTimeframe === 'D') {
                        candleData = DataAggregator.aggregateTimeSeriesData(candleData, 'W');
                        console.log(`📊 API data aggregated to weekly: ${candleData.length} candles`);
                    } else if (currentTimeframe === '3D' && apiTimeframe === 'D') {
                        candleData = DataAggregator.aggregateTimeSeriesData(candleData, '3D');
                        console.log(`📊 API data aggregated to 3-day: ${candleData.length} candles`);
                    }

                    return candleData;
                } else {
                    console.error('❌ API response error details:');
                    console.error('- Status:', apiData.s);
                    console.error('- Message:', apiData.errmsg || 'No error message');
                    console.error('- Has time data:', !!apiData.t);
                    console.error('- Has OHLC data:', !!apiData.o && !!apiData.h && !!apiData.l && !!apiData.c);
                    
                    if (apiData.s === 'no_data') {
                        console.warn('⚠️ No data available for the requested period');
                        return [];
                    }
                    
                    throw new Error(`API error: ${apiData.s} - ${apiData.errmsg || 'Unknown error'}`);
                }

            } catch (error) {
                console.error('❌ Error loading API data:', error);
                console.error('❌ Error type:', error.constructor.name);
                console.error('❌ Error message:', error.message);
                return [];
            }
        }

        async function loadInstrumentCSVData(instrument) {
            try {
                // Для 3D таймфрейма загружаем дневные данные и агрегируем их локально
                const timeframeSuffix = TimeframeUtils.getFileSuffix(currentTimeframe);
                
                if (currentTimeframe === '3D') {
                    console.log(`📊 Loading 1D CSV data for 3D timeframe (will be aggregated locally)`);
                }
                
                // Попробуем разные варианты названий файлов
                const possibleFiles = [
                    `${instrument.path}TVC_${currentComparisonInstrument.toUpperCase()}, ${timeframeSuffix}.csv`,
                    `${instrument.path}SP_${currentComparisonInstrument.toUpperCase()}, ${timeframeSuffix}.csv`,
                    `${instrument.path}${currentComparisonInstrument.toUpperCase()}, ${timeframeSuffix}.csv`
                ];
                
                for (const filePath of possibleFiles) {
                    const data = await loadCSVData(filePath);
                    if (data.length > 0) {
                        // Рассчитываем moving average если нужно
                        if (currentMAPeriod > 1) {
                            const rawValues = data.map(item => item.value);
                            const maValues = calculateMovingAverage(rawValues, currentMAPeriod);
                            
                            const maData = [];
                            const startIndex = currentMAPeriod - 1;
                            
                            for (let i = 0; i < maValues.length; i++) {
                                const originalIndex = startIndex + i;
                                if (originalIndex < data.length) {
                                    maData.push({
                                        time: data[originalIndex].time,
                                        value: maValues[i]
                                    });
                                }
                            }
                            
                            return aggregateDataByTimeframe(maData, currentTimeframe);
                        } else {
                            return aggregateDataByTimeframe(data, currentTimeframe);
                        }
                    }
                }
                
                return [];

            } catch (error) {
                console.error('❌ Error loading CSV instrument data:', error);
                return [];
            }
        }



        function createCoinbaseSeries() {
            if (!chart) {
                console.error('⚠️ Chart not initialized, cannot create Coinbase series');
                return;
            }
            
            try {
                // Удаляем существующую серию если есть
                if (coinbaseLineSeries) {
                    chart.removeSeries(coinbaseLineSeries);
                    coinbaseLineSeries = null;
                }
                
                // Создаем серию для Coinbase Index Moving Average (поверх основных данных)
                coinbaseLineSeries = chart.addLineSeries({
                    color: '#2962FF',           // TradingView синий - хорошо видно поверх
                    lineWidth: 3,               // Толще чем основные данные 
                    priceScaleId: 'left',       // Левая ось для ранга (1-100)
                    title: `Coinbase Index MA${currentMAPeriod}`,
                    lastValueVisible: true,
                    priceLineVisible: true,
                    crosshairMarkerVisible: true,
                    crosshairMarkerRadius: 5,
                    crosshairMarkerBorderColor: '#2962FF',
                    crosshairMarkerBackgroundColor: '#2962FF',
                });
                
                if (!coinbaseLineSeries) {
                    throw new Error('Failed to create line series - returned null');
                }
                
                console.log(`✅ Coinbase MA${currentMAPeriod} series created (overlay)`);
                
            } catch (error) {
                console.error('❌ Error creating Coinbase series:', error);
                console.error('❌ Chart object available methods:', Object.keys(chart).filter(k => typeof chart[k] === 'function'));
                throw new Error('Failed to create Coinbase MA series');
            }
        }

        function createComparisonSeries() {
            if (!chart) {
                console.error('⚠️ Chart not initialized, cannot create comparison series');
                return;
            }
            
            try {
                // Удаляем существующую серию если есть
                if (comparisonLineSeries) {
                    chart.removeSeries(comparisonLineSeries);
                    comparisonLineSeries = null;
                }
                
                // Получаем настройки инструмента
                const instrument = CONFIG.INSTRUMENTS[currentComparisonInstrument];
                if (!instrument) {
                    console.error(`❌ Unknown comparison instrument: ${currentComparisonInstrument}`);
                    return;
                }
                
                // Определяем цвет (более приглушенный, так как это фоновые данные)
                const colors = {
                    'btc': '#F7931A',    
                    'spx': '#4285F4',    
                    'vix': '#DB4437',    
                    'dxy': '#0F9D58',    
                    'total3esbtc': '#FF6B35',
                    'withoutbtceth': '#6A4C93'
                };
                
                const seriesColor = colors[currentComparisonInstrument] || instrument.color || '#FF9800';
                
                // Создаем серию (основные данные, на которые накладывается MA)
                if (instrument.seriesType === 'candlestick') {
                    comparisonLineSeries = chart.addCandlestickSeries({
                        upColor: '#00C851',
                        downColor: '#FF4444',
                        borderVisible: true,
                        wickUpColor: '#00C851',
                        wickDownColor: '#FF4444',
                        borderUpColor: '#00C851',
                        borderDownColor: '#FF4444',
                        priceScaleId: 'right',      // Правая ось для цены
                        title: instrument.name,
                        lastValueVisible: true,
                        priceLineVisible: false,    // Убираем чтобы не мешало MA
                        crosshairMarkerVisible: true,
                    });
                } else {
                    comparisonLineSeries = chart.addLineSeries({
                        color: seriesColor,
                        lineWidth: 2,
                        priceScaleId: 'right',      // Правая ось для цены/индекса
                        title: instrument.name,
                        lastValueVisible: true,
                        priceLineVisible: false,    // Убираем чтобы не мешало MA
                        crosshairMarkerVisible: true,
                        crosshairMarkerRadius: 4,
                        crosshairMarkerBorderColor: seriesColor,
                        crosshairMarkerBackgroundColor: seriesColor,
                    });
                }
                
                if (!comparisonLineSeries) {
                    throw new Error('Failed to create comparison series - returned null');
                }
                
                console.log(`✅ ${instrument.name} series created (background data for MA overlay)`);
                
                // Обновляем информацию о символе
                updateSymbolInfo(currentComparisonInstrument);
                
            } catch (error) {
                console.error('❌ Error creating comparison series:', error);
                console.error('❌ Chart object available methods:', Object.keys(chart).filter(k => typeof chart[k] === 'function'));
                throw new Error('Failed to create comparison series');
            }
        }

        function parseDateString(dateStr) {
            try {
                // Парсим строку типа "Fri, Jul 4, 25"
                const parts = dateStr.split(',').map(s => s.trim());
                if (parts.length !== 3) return null;

                const monthDay = parts[1]; // "Jul 4"
                const year = parts[2]; // "25"

                // Преобразуем короткий год в полный
                let fullYear;
                if (year.length === 2) {
                    const yearNum = parseInt(year);
                    // Для данных: "25" должно быть 2023, но поскольку у нас "25" в данных 
                    // вероятно означает 2023 год, используем простое правило:
                    // 00-30 = 20xx, 31-99 = 19xx
                    fullYear = yearNum <= 30 ? '20' + year : '19' + year;
                } else {
                    fullYear = year;
                }

                // Создаем полную дату
                const fullDate = `${monthDay}, ${fullYear}`;
                const date = new Date(fullDate);

                if (isNaN(date.getTime())) return null;

                return DateUtils.toTimestamp(date);
            } catch (error) {
                console.warn('⚠️ Error parsing date:', dateStr, error);
                return null;
            }
        }

        async function initializeChart() {
            try {
                const container = document.getElementById('chart-container');
                if (!container) {
                    throw new Error('Chart container not found');
                }

                updateStatus('Инициализация графика...', 'info');

                // Убеждаемся что TradingView Charts загружена
                if (typeof LightweightCharts === 'undefined') {
                    console.log('⏳ Waiting for TradingView Lightweight Charts to load...');
                    await waitForTradingViewCharts();
                }

                console.log('✅ TradingView Lightweight Charts is available');

                // Очищаем контейнер
                container.innerHTML = '';

                // Создаем график с простой конфигурацией
                chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: 600,
                    layout: {
                        backgroundColor: '#0D1421',
                        textColor: '#B2B5BE',
                    },
                    grid: {
                        vertLines: { 
                            color: 'rgba(42, 46, 57, 0.3)',
                        },
                        horzLines: { 
                            color: 'rgba(42, 46, 57, 0.3)',
                        },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#2A2E39',
                        visible: true,
                    },
                    leftPriceScale: {
                        borderColor: '#2A2E39',
                        visible: true,
                    },
                    timeScale: {
                        borderColor: '#2A2E39',
                        timeVisible: true,
                    },
                });

                console.log('✅ Chart created successfully');

                // Создаем серии
                createCoinbaseSeries();
                createComparisonSeries();

                // Обработчик изменения размера окна
                window.addEventListener('resize', () => {
                    if (chart && chart.applyOptions) {
                        chart.applyOptions({ width: container.clientWidth });
                    }
                });

                console.log('✅ Lightweight Charts initialized');
                updateStatus('График инициализирован', 'success');

            } catch (error) {
                console.error('❌ Chart initialization failed:', error);
                updateStatus(`Ошибка инициализации графика: ${error.message}`, 'error');
                throw error;
            }
        }

        async function loadData() {
            try {
                updateStatus(CONFIG.MESSAGES.LOADING, 'info');

                // Получаем выбранные даты
                const fromDateValue = document.getElementById('fromDate').value;
                const toDateValue = document.getElementById('toDate').value;
                
                // Определяем общую начальную дату для синхронизации
                const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
                const commonStartTime = DateUtils.toTimestamp(new Date(commonStartDate));
                
                // Преобразуем даты в timestamp с учетом общей начальной даты
                const requestedFromTime = fromDateValue ? DateUtils.toTimestamp(new Date(fromDateValue)) : commonStartTime;
                const effectiveFromTime = Math.max(requestedFromTime, commonStartTime); // Не раньше общей даты
                const toTime = toDateValue ? DateUtils.toTimestamp(new Date(toDateValue + 'T23:59:59')) : DateUtils.toTimestamp(new Date());
                
                console.log(`📅 Requested from: ${DateUtils.toLocaleDateString(requestedFromTime)}`);
                console.log(`📅 Common start: ${DateUtils.toLocaleDateString(commonStartTime)}`);
                console.log(`📅 Effective from: ${DateUtils.toLocaleDateString(effectiveFromTime)}`);
                console.log(`📅 To: ${DateUtils.toLocaleDateString(toTime)}`);
                
                // Используем эффективную дату для всех запросов
                const fromTime = effectiveFromTime;

                // Получаем выбранный таймфрейм
                const timeframeSelect = document.getElementById('timeframeSelect');
                currentTimeframe = timeframeSelect ? timeframeSelect.value : 'W';
                
                // 1. Всегда загружаем данные Coinbase Index
                console.log('📊 Loading Coinbase Index data...');
                await loadCoinbaseData(fromTime, toTime);
                
                // 2. Загружаем данные выбранного инструмента для сравнения
                console.log(`📊 Loading comparison instrument: ${CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name}...`);
                await loadComparisonInstrumentData(fromTime, toTime);

                // Обновляем легенду
                updateLegend();
                
                // Получаем данные из серий для обновления цен
                let coinbaseSeriesData = null;
                let comparisonSeriesData = null;
                
                try {
                    if (coinbaseLineSeries && coinbaseLineSeries.data) {
                        coinbaseSeriesData = coinbaseLineSeries.data();
                    }
                    if (comparisonLineSeries && comparisonLineSeries.data) {
                        comparisonSeriesData = comparisonLineSeries.data();
                    }
                } catch (error) {
                    console.warn('⚠️ Could not get series data for price update:', error);
                }
                
                // Обновляем данные цен в верхней панели
                updatePriceData(coinbaseSeriesData, comparisonSeriesData);
                
                // Обновляем информацию о символе
                updateSymbolInfo(currentComparisonInstrument);
                
                // Автоматически подгоняем график под загруженные данные
                setTimeout(() => {
                    refreshChart();
                }, 300);
                
                setTimeout(() => {
                    refreshChart();
                }, 800);
                
                // Финальная подгонка
                setTimeout(() => {
                    fitAllContent();
                }, 1200);
                
                const timeframeText = TimeframeUtils.getDisplayText(currentTimeframe);
                const coinbaseName = `Coinbase Index MA${currentMAPeriod}`;
                const comparisonName = CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name || 'Unknown';
                const commonDate = DateUtils.toLocaleDateString(commonStartTime);
                updateStatus(`📊 ${coinbaseName} overlay on ${comparisonName} | ${timeframeText} | Данные с ${commonDate}`, 'success');

            } catch (error) {
                console.error('❌ Error loading data:', error);
                updateStatus(CONFIG.MESSAGES.ERROR, 'error');
            }
        }



        function setupScaleSynchronization() {
            if (!chart) return;
            
            try {
                // Отключаем потенциально проблемную синхронизацию
                // которая может вызывать циклические события
                
                console.log('✅ Scale synchronization setup completed (minimal)');
            } catch (error) {
                console.warn('⚠️ Scale synchronization not available:', error);
            }
        }

        function refreshChart() {
            if (!chart) {
                console.warn('⚠️ Chart not initialized, cannot refresh');
                return;
            }
            
            try {
                console.log('🔄 Refreshing chart layout...');
                
                // Принудительно подгоняем временную шкалу
                const timeScale = chart.timeScale();
                timeScale.fitContent();
                
                // Принудительно обновляем размеры
                const container = document.getElementById('chart-container');
                if (container) {
                    chart.resize(container.clientWidth, 600);
                }
                
                // Автомасштабирование ценовых шкал с принудительным обновлением
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                    console.log('📊 BTC price scale (right) refreshed');
                }
                
                const leftPriceScale = chart.priceScale('left');
                if (leftPriceScale) {
                    leftPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                    console.log('📊 Instrument price scale (left) refreshed');
                }
                
                // Дополнительная подгонка временной шкалы
                setTimeout(() => {
                    timeScale.fitContent();
                }, 50);
                
                console.log('✅ Chart refreshed successfully');
            } catch (error) {
                console.warn('⚠️ Error refreshing chart:', error);
            }
        }

        function setOptimalInitialRange() {
            if (!chart) return;
            
            try {
                console.log('🎯 Setting optimal initial time range...');
                
                // Устанавливаем видимый диапазон на последние 2 года
                const now = Math.floor(Date.now() / 1000);
                const twoYearsAgo = now - (2 * 365 * 24 * 60 * 60); // 2 года назад
                
                const timeScale = chart.timeScale();
                timeScale.setVisibleRange({
                    from: twoYearsAgo,
                    to: now
                });
                
                console.log('📊 Initial range set to last 2 years for better visibility');
            } catch (error) {
                console.warn('⚠️ Could not set initial range:', error);
            }
        }

        function resetAllScaling() {
            if (!chart) {
                console.warn('⚠️ Chart not initialized, cannot reset scaling');
                return;
            }
            
            try {
                console.log('🔄 Resetting all chart scaling...');
                
                // Используем TimeScale Manager для сброса временной шкалы
                if (window.timeScaleManager && window.timeScaleManager.isInitialized) {
                    window.timeScaleManager.resetTimeScale();
                } else {
                    // Fallback на прямой вызов
                    const timeScale = chart.timeScale();
                    if (timeScale.resetTimeScale) {
                        timeScale.resetTimeScale();
                    } else {
                        timeScale.fitContent();
                    }
                }
                
                // Сбрасываем правую ценовую шкалу (BTC)
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                }
                
                // Сбрасываем левую ценовую шкалу (выбранный инструмент)
                const leftPriceScale = chart.priceScale('left');
                if (leftPriceScale) {
                    leftPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                }
                
                console.log('✅ All scaling reset successfully');
                updateStatus('Масштаб всех осей сброшен', 'success');
                
            } catch (error) {
                console.warn('⚠️ Error resetting scaling:', error);
                updateStatus('Ошибка сброса масштаба', 'error');
            }
        }

        function fitAllContent() {
            if (!chart) {
                console.warn('⚠️ Chart not initialized, cannot fit content');
                return;
            }
            
            try {
                console.log('🔄 Fitting all content...');
                
                // Используем TimeScale Manager для подгонки временной шкалы
                if (window.timeScaleManager && window.timeScaleManager.isInitialized) {
                    window.timeScaleManager.fitContent();
                } else {
                    // Fallback на прямой вызов
                    chart.timeScale().fitContent();
                }
                
                // Подгоняем правую ценовую шкалу
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        autoScale: true,
                    });
                }
                
                // Подгоняем левую ценовую шкалу  
                const leftPriceScale = chart.priceScale('left');
                if (leftPriceScale) {
                    leftPriceScale.applyOptions({
                        autoScale: true,
                    });
                }
                
                console.log('✅ All content fitted successfully');
                updateStatus('Все данные подогнаны под размер графика', 'success');
                
            } catch (error) {
                console.warn('⚠️ Error fitting content:', error);
                updateStatus('Ошибка подгонки содержимого', 'error');
            }
        }

        function setupEventHandlers() {
            // Проверяем существование DOM элементов
            const requiredElements = ['comparisonSelect', 'timeframeSelect', 'maPeriodSelect', 'fromDate', 'toDate', 'resetScale', 'fitContent'];
            for (const elementId of requiredElements) {
                if (!document.getElementById(elementId)) {
                    console.error(`❌ Required DOM element not found: ${elementId}`);
                    updateStatus(`Ошибка: элемент ${elementId} не найден`, 'error');
                    return;
                }
            }
            
            // Смена инструмента для сравнения
            document.getElementById('comparisonSelect').addEventListener('change', async (e) => {
                currentComparisonInstrument = e.target.value;
                console.log(`📊 Comparison instrument changed to: ${currentComparisonInstrument}`);
                
                // Обновляем селектор таймфреймов для нового инструмента
                updateTimeframeSelector(currentComparisonInstrument);
                
                // Пересоздаем серию для нового инструмента
                createComparisonSeries();
                
                // Обновляем дату начала при смене инструмента
                await DataUpdateUtils.updateStartDateAndReload('доступности данных');
            });
            
            // Смена таймфрейма
            document.getElementById('timeframeSelect').addEventListener('change', async (e) => {
                currentTimeframe = e.target.value;
                console.log(`📊 Timeframe changed to: ${currentTimeframe}`);
                
                // Обновляем дату начала при смене таймфрейма
                await DataUpdateUtils.updateStartDateAndReload('доступности данных');
            });
            
            // Смена периода MA
            document.getElementById('maPeriodSelect').addEventListener('change', (e) => {
                currentMAPeriod = parseInt(e.target.value);
                loadData();
            });

            // Изменение дат
            document.getElementById('fromDate').addEventListener('change', async (e) => {
                const selectedDate = e.target.value;
                console.log(`📅 FROM date changed to: ${selectedDate}`);
                
                // Проверяем общую доступность данных
                const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
                const commonStartTime = new Date(commonStartDate);
                const selectedTime = new Date(selectedDate);
                
                if (selectedTime < commonStartTime) {
                    console.warn(`⚠️ Selected date (${selectedDate}) is before common data availability (${commonStartDate})`);
                    updateStatus(`Выбранная дата раньше общей доступности данных (с ${DateUtils.toLocaleDateString(DateUtils.toTimestamp(new Date(commonStartDate)))}). Дата будет скорректирована.`, 'info');
                    
                    // Автоматически корректируем дату
                    e.target.value = commonStartDate;
                    fromDate = commonStartDate;
                } else {
                    fromDate = selectedDate;
                }
                
                console.log('🔄 Reloading data with new date range...');
                loadData();
            });

            document.getElementById('toDate').addEventListener('change', (e) => {
                toDate = e.target.value;
                console.log(`📅 TO date changed to: ${toDate}`);
                console.log('🔄 Reloading data with new date range...');
                loadData();
            });

            // Кнопки управления масштабом
            document.getElementById('resetScale').addEventListener('click', () => {
                console.log('🔄 Reset scale button clicked');
                resetAllScaling();
            });

            document.getElementById('fitContent').addEventListener('click', () => {
                console.log('📏 Fit content button clicked');
                fitAllContent();
            });

            // Кнопка добавления индикаторов
            document.getElementById('addIndicator').addEventListener('click', () => {
                addSelectedIndicator();
            });

            // Быстрый выбор временного диапазона
            document.getElementById('quickTimeRange').addEventListener('change', (e) => {
                handleQuickTimeRangeSelection(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // Переключение темы
            document.getElementById('toggleTheme').addEventListener('click', () => {
                toggleChartTheme();
            });

            // Переключение сетки
            document.getElementById('toggleGrid').addEventListener('click', () => {
                toggleChartGrid();
            });

            // Добавление уровней цен
            document.getElementById('addPriceLevels').addEventListener('change', (e) => {
                handlePriceLevelAdd(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // ===============================================
            // ОБРАБОТЧИКИ НОВЫХ ФУНКЦИЙ
            // ===============================================

            // Экспорт
            document.getElementById('exportOptions').addEventListener('change', (e) => {
                handleExportAction(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // Добавление серий
            document.getElementById('seriesOptions').addEventListener('change', (e) => {
                handleSeriesAdd(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // Изменение режима шкалы цен
            document.getElementById('priceScaleMode').addEventListener('change', (e) => {
                handlePriceScaleModeChange(e.target.value);
            });

            // Сохранение состояния
            document.getElementById('saveState').addEventListener('click', () => {
                handleSaveState();
            });

            // Полноэкранный режим
            document.getElementById('toggleFullscreen').addEventListener('click', () => {
                handleToggleFullscreen();
            });

            // Candlestick серии
            document.getElementById('candlestickOptions').addEventListener('change', (e) => {
                handleCandlestickAdd(e.target.value);
                e.target.value = '';
            });

            // Функции времени
            document.getElementById('timeFeatures').addEventListener('change', (e) => {
                handleTimeFeature(e.target.value);
                e.target.value = '';
            });

            // Режим crosshair
            document.getElementById('crosshairMode').addEventListener('change', (e) => {
                handleCrosshairModeChange(e.target.value);
            });

            // Анимационные эффекты
            document.getElementById('animationEffects').addEventListener('change', (e) => {
                handleAnimationEffect(e.target.value);
                e.target.value = '';
            });

            // Переключение анимаций
            document.getElementById('toggleAnimations').addEventListener('click', () => {
                handleToggleAnimations();
            });

            // Устанавливаем обработчики для новых элементов toolbar
            setupToolbarHandlers();

            // ===============================================
            // ОБРАБОТЧИКИ TRADINGVIEW-STYLE ИНТЕРФЕЙСА
            // ===============================================

            // Боковая панель
            setupSidebarHandlers();

            // Правая панель (watchlist)
            setupWatchlistHandlers();

            // Панель инструментов
            setupTradingViewToolbarHandlers();

            console.log('✅ All event handlers set up successfully');
        }

        function setupSidebarHandlers() {
            const sidebarTools = document.querySelectorAll('.sidebar-tool');
            
            sidebarTools.forEach(tool => {
                tool.addEventListener('click', () => {
                    // Убираем активный класс со всех инструментов
                    sidebarTools.forEach(t => t.classList.remove('active'));
                    
                    // Добавляем активный класс к выбранному инструменту
                    tool.classList.add('active');
                    
                    // Обрабатываем действие в зависимости от ID
                    const toolId = tool.id;
                    switch(toolId) {
                        case 'sidebar-chart':
                            showChartPanel();
                            break;
                        case 'sidebar-indicators':
                            showIndicatorsPanel();
                            break;
                        case 'sidebar-drawing':
                            showDrawingPanel();
                            break;
                        case 'sidebar-alerts':
                            showAlertsPanel();
                            break;
                        case 'sidebar-settings':
                            showSettingsPanel();
                            break;
                        default:
                            console.log(`Sidebar tool clicked: ${toolId}`);
                    }
                });
            });
        }

        function setupWatchlistHandlers() {
            const watchlistItems = document.querySelectorAll('.watchlist-item');
            
            watchlistItems.forEach(item => {
                item.addEventListener('click', () => {
                    // Убираем активный класс со всех элементов
                    watchlistItems.forEach(i => i.classList.remove('active'));
                    
                    // Добавляем активный класс к выбранному элементу
                    item.classList.add('active');
                    
                    // Получаем символ и обновляем график
                    const symbol = item.dataset.symbol;
                    if (symbol && symbol !== currentComparisonInstrument) {
                        currentComparisonInstrument = symbol;
                        
                        // Обновляем селектор
                        const comparisonSelect = document.getElementById('comparisonSelect');
                        if (comparisonSelect) {
                            comparisonSelect.value = symbol;
                        }
                        
                        // Обновляем данные
                        updateTimeframeSelector(currentComparisonInstrument);
                        createComparisonSeries();
                        DataUpdateUtils.updateStartDateAndReload('смены инструмента');
                        
                        updateStatus(`📊 Coinbase Index vs ${CONFIG.INSTRUMENTS[symbol]?.name || symbol} - корреляционный анализ`, 'success');
                    }
                });
            });
        }

        function setupTradingViewToolbarHandlers() {
            // Обработчики для панели таймфреймов
            const timeframeButtons = document.querySelectorAll('.toolbar-panel .toolbar-btn');
            
            timeframeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const timeframeText = button.textContent.trim();
                    
                    // Маппинг кнопок на значения таймфреймов
                    const timeframeMap = {
                        '1s': '1',
                        '1m': '1',
                        '5m': '5',
                        '15m': '15',
                        '30m': '30',
                        '1h': '60',
                        '4h': '240',
                        '1D': 'D',
                        '1W': 'W',
                        '1M': 'M'
                    };
                    
                    const newTimeframe = timeframeMap[timeframeText];
                    if (newTimeframe && getSupportedTimeframes(currentComparisonInstrument).includes(newTimeframe)) {
                        // Убираем активный класс со всех кнопок
                        timeframeButtons.forEach(btn => btn.classList.remove('active'));
                        
                        // Добавляем активный класс к выбранной кнопке
                        button.classList.add('active');
                        
                        // Обновляем таймфрейм
                        currentTimeframe = newTimeframe;
                        
                        // Обновляем селектор
                        const timeframeSelect = document.getElementById('timeframeSelect');
                        if (timeframeSelect) {
                            timeframeSelect.value = newTimeframe;
                        }
                        
                        // Обновляем данные
                        DataUpdateUtils.updateStartDateAndReload('смены таймфрейма');
                        updateStatus(`Таймфрейм изменен на ${timeframeText}`, 'success');
                    } else {
                        updateStatus(`Таймфрейм ${timeframeText} не поддерживается для ${CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name}`, 'error');
                    }
                });
            });
        }

        function showChartPanel() {
            updateStatus('Панель графика активна', 'info');
        }

        function showDrawingPanel() {
            updateStatus('Инструменты рисования пока не доступны', 'info');
        }

        function showAlertsPanel() {
            updateStatus('Настройка оповещений пока не доступна', 'info');
        }

        function showSettingsPanel() {
            // Создаем модальное окно для настроек
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const panel = document.createElement('div');
            panel.style.cssText = `
                background: #1e222d;
                border: 1px solid #2a2e39;
                border-radius: 8px;
                padding: 20px;
                max-width: 400px;
                color: #d1d4dc;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            panel.innerHTML = `
                <h3 style="margin-top: 0; color: #ffffff;">Настройки</h3>
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">Тема:</label>
                    <button onclick="toggleChartTheme()" style="padding: 8px 16px; background: #2962ff; color: white; border: none; border-radius: 4px; cursor: pointer;">Переключить тему</button>
                </div>
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">Сетка:</label>
                    <button onclick="toggleChartGrid()" style="padding: 8px 16px; background: #2962ff; color: white; border: none; border-radius: 4px; cursor: pointer;">Переключить сетку</button>
                </div>
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">Полный экран:</label>
                    <button onclick="handleToggleFullscreen()" style="padding: 8px 16px; background: #2962ff; color: white; border: none; border-radius: 4px; cursor: pointer;">Полный экран</button>
                </div>
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">Анимации:</label>
                    <button onclick="handleToggleAnimations()" style="padding: 8px 16px; background: #2962ff; color: white; border: none; border-radius: 4px; cursor: pointer;">Переключить анимации</button>
                </div>
                <div style="margin: 15px 0;">
                    <button onclick="handleSaveState()" style="padding: 8px 16px; background: #00c851; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">Сохранить состояние</button>
                    <button onclick="this.closest('.modal').remove()" style="padding: 8px 16px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Закрыть</button>
                </div>
            `;
            
            modal.className = 'modal';
            modal.appendChild(panel);
            document.body.appendChild(modal);
            
            // Закрытие по клику вне панели
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        function updatePriceData(coinbaseData, comparisonData) {
            // Обновляем данные Coinbase Index (ранг)
            if (coinbaseData && coinbaseData.length > 0) {
                const latestCoinbase = coinbaseData[coinbaseData.length - 1];
                const previousCoinbase = coinbaseData.length > 1 ? coinbaseData[coinbaseData.length - 2] : latestCoinbase;
                
                const coinbaseRank = document.getElementById('coinbase-rank');
                const rankChange = document.getElementById('rank-change');
                
                if (coinbaseRank) {
                    const currentRank = latestCoinbase.value || latestCoinbase.close || latestCoinbase;
                    coinbaseRank.textContent = currentRank?.toFixed(1) || '-';
                }
                
                if (rankChange && typeof latestCoinbase.value === 'number' && typeof previousCoinbase.value === 'number') {
                    const change = latestCoinbase.value - previousCoinbase.value;
                    const changePercent = (change / previousCoinbase.value) * 100;
                    
                    const sign = change >= 0 ? '+' : '';
                    rankChange.textContent = `${sign}${changePercent.toFixed(2)}%`;
                    rankChange.className = change >= 0 ? 'price-change positive' : 'price-change negative';
                }
            }
            
            // Обновляем данные инструмента сравнения
            if (comparisonData && comparisonData.length > 0) {
                const latestComparison = comparisonData[comparisonData.length - 1];
                const previousComparison = comparisonData.length > 1 ? comparisonData[comparisonData.length - 2] : latestComparison;
                
                const comparisonPrice = document.getElementById('comparison-price');
                const comparisonChange = document.getElementById('comparison-change');
                
                if (comparisonPrice) {
                    const currentPrice = latestComparison.value || latestComparison.close || latestComparison;
                    
                    // Форматируем цену в зависимости от инструмента
                    let formattedPrice = '-';
                    if (typeof currentPrice === 'number') {
                        if (currentComparisonInstrument === 'btc') {
                            formattedPrice = `$${currentPrice.toLocaleString()}`;
                        } else if (currentComparisonInstrument === 'spx') {
                            formattedPrice = currentPrice.toFixed(0);
                        } else {
                            formattedPrice = currentPrice.toFixed(2);
                        }
                    }
                    
                    comparisonPrice.textContent = formattedPrice;
                }
                
                if (comparisonChange && typeof latestComparison.value === 'number' && typeof previousComparison.value === 'number') {
                    const change = latestComparison.value - previousComparison.value;
                    const changePercent = (change / previousComparison.value) * 100;
                    
                    const sign = change >= 0 ? '+' : '';
                    comparisonChange.textContent = `${sign}${changePercent.toFixed(2)}%`;
                    comparisonChange.className = change >= 0 ? 'price-change positive' : 'price-change negative';
                }
            }
        }

        function updateSymbolInfo(instrumentKey) {
            const instrument = CONFIG.INSTRUMENTS[instrumentKey];
            if (!instrument) return;
            
            // Обновляем инструмент сравнения в верхней панели
            const comparisonInstrument = document.getElementById('comparison-instrument');
            const comparisonLabel = document.getElementById('comparison-label');
            
            if (comparisonInstrument) {
                comparisonInstrument.textContent = CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name || 'Unknown';
            }
            
            if (comparisonLabel) {
                comparisonLabel.textContent = CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name || 'Unknown';
                
                // Устанавливаем цвет метки
                const colors = {
                    'btc': '#F7931A',
                    'spx': '#4285F4',
                    'vix': '#DB4437',
                    'dxy': '#0F9D58',
                    'total3esbtc': '#FF6B35',
                    'withoutbtceth': '#6A4C93'
                };
                
                comparisonLabel.style.color = colors[currentComparisonInstrument] || '#FF9800';
            }
            
            // Обновляем детали символа
            const symbolDetails = document.querySelector('.symbol-details');
            if (symbolDetails) {
                const timeframeText = TimeframeUtils.getDisplayText(currentTimeframe);
                const comparisonName = CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name || 'Unknown';
                symbolDetails.innerHTML = `Основная кривая • vs <span id="comparison-instrument">${comparisonName}</span> • ${timeframeText} • charts.expert`;
            }
        }

        function updateLegend() {
            // Обновляем легенду Coinbase Index (всегда Coinbase)
            const coinbaseLegendElement = document.getElementById('coinbase-legend');
            const coinbaseLegendLineElement = document.querySelector('.legend-instrument');
            
            if (coinbaseLegendElement && coinbaseLegendLineElement) {
                const coinbaseInstrument = CONFIG.INSTRUMENTS['coinbase'];
                if (coinbaseInstrument) {
                    coinbaseLegendElement.textContent = coinbaseInstrument.name;
                    coinbaseLegendLineElement.style.background = `linear-gradient(135deg, ${coinbaseInstrument.color}, ${coinbaseInstrument.color}aa)`;
                }
            }
            
            // Обновляем легенду инструмента сравнения
            const comparisonLegendElement = document.getElementById('comparison-legend');
            const comparisonLegendLineElement = document.querySelector('.legend-comparison');
            
            if (comparisonLegendElement && comparisonLegendLineElement) {
                const comparisonInstrument = CONFIG.INSTRUMENTS[currentComparisonInstrument];
                if (comparisonInstrument) {
                    comparisonLegendElement.textContent = comparisonInstrument.name;
                    comparisonLegendLineElement.style.background = `linear-gradient(135deg, ${comparisonInstrument.color}, ${comparisonInstrument.color}aa)`;
                }
            }
        }

        function getSupportedTimeframes(comparisonInstrumentKey) {
            // Получаем поддерживаемые таймфреймы для Coinbase и выбранного инструмента
            const coinbaseInstrument = CONFIG.INSTRUMENTS['coinbase'];
            const comparisonInstrument = CONFIG.INSTRUMENTS[comparisonInstrumentKey];
            
            if (!coinbaseInstrument || !comparisonInstrument) {
                console.warn('⚠️ Instrument not found, returning default timeframes');
                return ['D', '3D', 'W']; // Безопасный fallback
            }
            
            // Находим пересечение поддерживаемых таймфреймов
            const coinbaseTimeframes = coinbaseInstrument.supportedTimeframes || ['D', '3D', 'W'];
            const comparisonTimeframes = comparisonInstrument.supportedTimeframes || ['D', '3D', 'W'];
            
            const supportedTimeframes = coinbaseTimeframes.filter(tf => comparisonTimeframes.includes(tf));
            
            console.log(`📊 Supported timeframes for ${comparisonInstrumentKey}:`, supportedTimeframes);
            return supportedTimeframes;
        }

        function updateTimeframeSelector(comparisonInstrumentKey) {
            const timeframeSelect = document.getElementById('timeframeSelect');
            if (!timeframeSelect) {
                console.warn('⚠️ Timeframe selector not found');
                return;
            }
            
            // Получаем поддерживаемые таймфреймы
            const supportedTimeframes = getSupportedTimeframes(comparisonInstrumentKey);
            
            // Сохраняем текущий выбранный таймфрейм
            const currentSelectedTimeframe = timeframeSelect.value;
            
            // Очищаем селектор
            timeframeSelect.innerHTML = '';
            
            // Добавляем опции для поддерживаемых таймфреймов
            const timeframeOptions = {
                '240': '4H',
                'D': '1D',
                '3D': '3D',
                'W': '1W'
            };
            
            supportedTimeframes.forEach(tf => {
                const option = document.createElement('option');
                option.value = tf;
                option.textContent = timeframeOptions[tf] || tf;
                timeframeSelect.appendChild(option);
            });
            
            // Восстанавливаем выбранный таймфрейм, если он поддерживается
            if (supportedTimeframes.includes(currentSelectedTimeframe)) {
                timeframeSelect.value = currentSelectedTimeframe;
                currentTimeframe = currentSelectedTimeframe;
            } else {
                // Если текущий таймфрейм не поддерживается, выбираем первый доступный
                const newTimeframe = supportedTimeframes[0] || 'D';
                timeframeSelect.value = newTimeframe;
                currentTimeframe = newTimeframe;
                console.log(`📊 Timeframe changed to ${currentTimeframe} (${comparisonInstrumentKey} doesn't support ${currentSelectedTimeframe})`);
                updateStatus(`Таймфрейм изменен на ${currentTimeframe} (${comparisonInstrumentKey} не поддерживает ${currentSelectedTimeframe})`, 'info');
            }
            
            console.log(`✅ Timeframe selector updated for ${comparisonInstrumentKey}. Available: [${supportedTimeframes.join(', ')}], Selected: ${currentTimeframe}`);
        }

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            if (!statusEl) {
                console.warn('⚠️ Status element not found, logging message:', message);
                return;
            }
            
            statusEl.textContent = message;
            
            // Удаляем все предыдущие классы
            statusEl.className = 'status';
            
            // Добавляем соответствующий класс для типа
            switch (type) {
                case 'success':
                    statusEl.classList.add('success');
                    break;
                case 'error':
                    statusEl.classList.add('error');
                    break;
                case 'loading':
                    statusEl.classList.add('loading');
                    break;
                default:
                    statusEl.classList.add('info');
            }
        }

        // ===============================================
        // ФУНКЦИИ ДЛЯ РАБОТЫ С ТЕХНИЧЕСКИМИ ИНДИКАТОРАМИ
        // ===============================================

        function addSelectedIndicator() {
            const indicatorSelect = document.getElementById('indicatorSelect');
            const selectedType = indicatorSelect.value;
            
            if (!selectedType) {
                updateStatus('Выберите индикатор для добавления', 'error');
                return;
            }
            
            if (!window.indicatorsManager) {
                updateStatus('Менеджер индикаторов не инициализирован', 'error');
                return;
            }
            
            // Получаем данные для индикатора
            const chartData = getCombinedChartData();
            if (!chartData || chartData.length === 0) {
                updateStatus('Нет данных для расчета индикатора', 'error');
                return;
            }
            
            try {
                // Устанавливаем данные в менеджер индикаторов
                window.indicatorsManager.setData(chartData);
                
                // Определяем параметры по умолчанию для разных типов индикаторов
                const defaultParams = getDefaultIndicatorParams(selectedType);
                const indicatorName = `${selectedType}_${Date.now()}`;
                
                // Добавляем индикатор
                const success = window.indicatorsManager.addIndicator(
                    indicatorName, 
                    selectedType, 
                    defaultParams
                );
                
                if (success) {
                    updateStatus(`✅ Индикатор ${selectedType.toUpperCase()} добавлен`, 'success');
                    // Сбрасываем выбор
                    indicatorSelect.value = '';
                } else {
                    updateStatus(`❌ Ошибка добавления индикатора ${selectedType}`, 'error');
                }
                
            } catch (error) {
                console.error('❌ Error adding indicator:', error);
                updateStatus(`Ошибка добавления индикатора: ${error.message}`, 'error');
            }
        }

        function getCombinedChartData() {
            // Пытаемся получить данные из основного инструмента (comparison)
            if (comparisonLineSeries && comparisonLineSeries.data) {
                return comparisonLineSeries.data().map((item, index) => ({
                    time: item.time,
                    close: item.value,
                    high: item.value * 1.01,
                    low: item.value * 0.99,
                    open: item.value
                }));
            }
            
            // Альтернативно используем данные Coinbase Index
            if (coinbaseLineSeries && coinbaseLineSeries.data) {
                return coinbaseLineSeries.data().map((item, index) => ({
                    time: item.time,
                    close: item.value,
                    high: item.value * 1.01,
                    low: item.value * 0.99,
                    open: item.value
                }));
            }
            
            // Генерируем тестовые данные если основные недоступны
            console.warn('⚠️ No chart data available, generating test data');
            const testData = [];
            const startTime = Math.floor(Date.now() / 1000) - (365 * 24 * 60 * 60);
            
            for (let i = 0; i < 100; i++) {
                const time = startTime + (i * 24 * 60 * 60);
                const baseValue = 50000 + Math.sin(i * 0.1) * 10000;
                testData.push({
                    time: time,
                    close: baseValue,
                    high: baseValue * 1.02,
                    low: baseValue * 0.98,
                    open: baseValue
                });
            }
            
            return testData;
        }

        function getDefaultIndicatorParams(type) {
            switch (type.toLowerCase()) {
                case 'sma':
                case 'ema':
                    return { period: 14 };
                    
                case 'rsi':
                    return { period: 14 };
                    
                case 'macd':
                    return { fast: 12, slow: 26, signal: 9 };
                    
                case 'bollinger':
                case 'bb':
                    return { period: 20, stdDev: 2 };
                    
                case 'stochastic':
                case 'stoch':
                    return { k: 14, d: 3 };
                    
                case 'cbma14':
                    return { period: 14, smoothing: 3 };
                    
                default:
                    return { period: 14 };
            }
        }

        // ===============================================
        // ФУНКЦИИ ДЛЯ РАБОТЫ С TIMESCALE API
        // ===============================================

        function handleQuickTimeRangeSelection(range) {
            if (!range || !window.timeScaleManager || !window.timeScaleManager.isInitialized) {
                return;
            }
            
            try {
                switch (range) {
                    case '7days':
                        window.timeScaleManager.setLastNDays(7);
                        updateStatus('Установлен диапазон: последние 7 дней', 'success');
                        break;
                        
                    case '30days':
                        window.timeScaleManager.setLastNDays(30);
                        updateStatus('Установлен диапазон: последние 30 дней', 'success');
                        break;
                        
                    case '3months':
                        window.timeScaleManager.setLastNMonths(3);
                        updateStatus('Установлен диапазон: последние 3 месяца', 'success');
                        break;
                        
                    case '6months':
                        window.timeScaleManager.setLastNMonths(6);
                        updateStatus('Установлен диапазон: последние 6 месяцев', 'success');
                        break;
                        
                    case '1year':
                        window.timeScaleManager.setLastNMonths(12);
                        updateStatus('Установлен диапазон: последний год', 'success');
                        break;
                        
                    case '2years':
                        window.timeScaleManager.setLastNMonths(24);
                        updateStatus('Установлен диапазон: последние 2 года', 'success');
                        break;
                        
                    case 'all':
                        window.timeScaleManager.fitContent();
                        updateStatus('Показаны все доступные данные', 'success');
                        break;
                        
                    default:
                        console.warn('Unknown time range:', range);
                }
                
            } catch (error) {
                console.error('❌ Error setting time range:', error);
                updateStatus(`Ошибка установки диапазона: ${error.message}`, 'error');
            }
        }

        function getTimeScaleInfo() {
            if (!window.timeScaleManager || !window.timeScaleManager.isInitialized) {
                return null;
            }
            
            return window.timeScaleManager.getTimeScaleInfo();
        }

        function optimizeDataForCurrentView(data) {
            if (!window.timeScaleManager || !window.timeScaleManager.isInitialized) {
                return data;
            }
            
                         return window.timeScaleManager.optimizeDataForCurrentRange(data, {
                 maxDataPoints: 1000,
                 minDataPoints: 100,
                 bufferSeconds: 86400 // 1 день буфер
             });
         }

         // ===============================================
         // ФУНКЦИИ ДЛЯ РАБОТЫ С ПРОДВИНУТЫМИ ВОЗМОЖНОСТЯМИ
         // ===============================================

         function toggleChartTheme() {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 updateStatus('Продвинутые возможности не инициализированы', 'error');
                 return;
             }
             
             try {
                 const currentTheme = window.advancedFeatures.currentTheme;
                 const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                 
                 window.advancedFeatures.setTheme(newTheme);
                 updateStatus(`Тема изменена на: ${newTheme === 'light' ? 'светлую' : 'тёмную'}`, 'success');
                 
             } catch (error) {
                 console.error('❌ Theme toggle error:', error);
                 updateStatus(`Ошибка смены темы: ${error.message}`, 'error');
             }
         }

         function toggleChartGrid() {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 updateStatus('Продвинутые возможности не инициализированы', 'error');
                 return;
             }
             
             try {
                 window.advancedFeatures.toggleGrid();
                 updateStatus('Видимость сетки переключена', 'success');
                 
             } catch (error) {
                 console.error('❌ Grid toggle error:', error);
                 updateStatus(`Ошибка переключения сетки: ${error.message}`, 'error');
             }
         }

         function handlePriceLevelAdd(levelType) {
             if (!levelType || !window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 return;
             }
             
             try {
                 // Получаем текущие данные для расчета уровней
                 const currentPrice = getCurrentPrice();
                 if (!currentPrice) {
                     updateStatus('Нет данных для расчета уровней', 'error');
                     return;
                 }
                 
                 switch (levelType) {
                     case 'support':
                         addSupportLevel(currentPrice);
                         break;
                         
                     case 'resistance':
                         addResistanceLevel(currentPrice);
                         break;
                         
                     case 'fibonacci':
                         addFibonacciLevels(currentPrice);
                         break;
                         
                     case 'pivot':
                         addPivotLevels(currentPrice);
                         break;
                         
                     default:
                         console.warn('Unknown level type:', levelType);
                 }
                 
             } catch (error) {
                 console.error('❌ Price level add error:', error);
                 updateStatus(`Ошибка добавления уровня: ${error.message}`, 'error');
             }
         }

         function getCurrentPrice() {
             try {
                 // Пытаемся получить текущую цену из данных сравнения
                 if (comparisonLineSeries && comparisonLineSeries.data) {
                     const data = comparisonLineSeries.data();
                     if (data && data.length > 0) {
                         return data[data.length - 1].value;
                     }
                 }
                 
                 // Альтернативно из данных Coinbase
                 if (coinbaseLineSeries && coinbaseLineSeries.data) {
                     const data = coinbaseLineSeries.data();
                     if (data && data.length > 0) {
                         return data[data.length - 1].value;
                     }
                 }
                 
                 return null;
                 
             } catch (error) {
                 console.error('❌ Get current price error:', error);
                 return null;
             }
         }

         function addSupportLevel(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Добавляем уровень поддержки на 5% ниже текущей цены
             const supportPrice = basePrice * 0.95;
             
             window.advancedFeatures.addPriceLine(series, supportPrice, {
                 color: '#00C851',
                 title: `Поддержка: ${supportPrice.toFixed(2)}`,
                 id: `support_${Date.now()}`,
                 lineStyle: LightweightCharts.LineStyle.Dashed
             });
             
             updateStatus(`Добавлен уровень поддержки: ${supportPrice.toFixed(2)}`, 'success');
         }

         function addResistanceLevel(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Добавляем уровень сопротивления на 5% выше текущей цены
             const resistancePrice = basePrice * 1.05;
             
             window.advancedFeatures.addPriceLine(series, resistancePrice, {
                 color: '#FF4444',
                 title: `Сопротивление: ${resistancePrice.toFixed(2)}`,
                 id: `resistance_${Date.now()}`,
                 lineStyle: LightweightCharts.LineStyle.Dashed
             });
             
             updateStatus(`Добавлен уровень сопротивления: ${resistancePrice.toFixed(2)}`, 'success');
         }

         function addFibonacciLevels(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Стандартные уровни Фибоначчи
             const fibLevels = [0.236, 0.382, 0.5, 0.618, 0.786];
             const range = basePrice * 0.1; // 10% диапазон
             
             fibLevels.forEach(level => {
                 const price = basePrice + (range * level) - (range * 0.5);
                 
                 window.advancedFeatures.addPriceLine(series, price, {
                     color: '#FFB74D',
                     title: `Фибо ${(level * 100).toFixed(1)}%: ${price.toFixed(2)}`,
                     id: `fib_${level}_${Date.now()}`,
                     lineWidth: 1,
                     lineStyle: LightweightCharts.LineStyle.Dotted
                 });
             });
             
             updateStatus(`Добавлены уровни Фибоначчи (${fibLevels.length})`, 'success');
         }

         function addPivotLevels(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Простые пивот уровни (упрощенная версия)
             const pivot = basePrice;
             const range = basePrice * 0.02; // 2% диапазон
             
             const levels = [
                 { price: pivot, label: 'Pivot', color: '#2962FF' },
                 { price: pivot + range, label: 'R1', color: '#FF6B6B' },
                 { price: pivot + range * 2, label: 'R2', color: '#FF6B6B' },
                 { price: pivot - range, label: 'S1', color: '#4ECDC4' },
                 { price: pivot - range * 2, label: 'S2', color: '#4ECDC4' }
             ];
             
             levels.forEach(level => {
                 window.advancedFeatures.addPriceLine(series, level.price, {
                     color: level.color,
                     title: `${level.label}: ${level.price.toFixed(2)}`,
                     id: `pivot_${level.label}_${Date.now()}`,
                     lineWidth: level.label === 'Pivot' ? 2 : 1
                 });
             });
             
             updateStatus(`Добавлены пивот уровни (${levels.length})`, 'success');
         }

         function addEventMarker(time, type, text) {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 return;
             }
             
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             return window.advancedFeatures.addMarker(series, time, {
                 position: type === 'bullish' ? 'belowBar' : 'aboveBar',
                 color: type === 'bullish' ? '#00C851' : '#FF4444',
                 shape: type === 'bullish' ? 'arrowUp' : 'arrowDown',
                 text: text,
                 id: `event_${Date.now()}`
             });
         }

         function getAdvancedFeaturesInfo() {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 return null;
             }
             
             return window.advancedFeatures.getFeatureInfo();
         }

         // ===============================================
         // ФУНКЦИИ ДЛЯ РАБОТЫ С НОВЫМИ ВОЗМОЖНОСТЯМИ
         // ===============================================

         function handleExportAction(exportType) {
             if (!exportType || !window.eventsAndExport || !window.eventsAndExport.isInitialized) {
                 return;
             }
             
             try {
                 switch (exportType) {
                     case 'image':
                         window.eventsAndExport.exportChartAsImage();
                         updateStatus('График экспортирован как изображение', 'success');
                         break;
                         
                     case 'csv':
                         window.eventsAndExport.exportDataAsCSV();
                         updateStatus('Данные экспортированы в CSV', 'success');
                         break;
                         
                     case 'json':
                         window.eventsAndExport.exportDataAsJSON();
                         updateStatus('Данные экспортированы в JSON', 'success');
                         break;
                         
                     default:
                         console.warn('Unknown export type:', exportType);
                 }
                 
             } catch (error) {
                 console.error('❌ Export error:', error);
                 updateStatus(`Ошибка экспорта: ${error.message}`, 'error');
             }
         }

         function handleSeriesAdd(seriesType) {
             if (!seriesType || !window.advancedSeriesAndScale || !window.advancedSeriesAndScale.isInitialized) {
                 return;
             }
             
             try {
                 const seriesId = `${seriesType}_${Date.now()}`;
                 
                 switch (seriesType) {
                                     // case 'volume':
                //     // Создаем тестовые данные объёмов
                //     const volumeData = generateVolumeData();
                //     window.advancedSeriesAndScale.createVolumesSeries(seriesId, volumeData);
                //     updateStatus('Серия объёмов добавлена', 'success');
                //     break;
                         
                     case 'area':
                         // Создаем область на основе текущих данных
                         const areaData = getCurrentChartData();
                         window.advancedSeriesAndScale.createTrendAreaSeries(seriesId, areaData);
                         updateStatus('Серия области добавлена', 'success');
                         break;
                         
                     case 'baseline':
                         // Создаем базовую линию
                         const baselineData = getCurrentChartData();
                         const baselineValue = calculateBaselineValue(baselineData);
                         window.advancedSeriesAndScale.createDeviationBaselineSeries(seriesId, baselineData, baselineValue);
                         updateStatus('Базовая линия добавлена', 'success');
                         break;
                         
                     default:
                         console.warn('Unknown series type:', seriesType);
                 }
                 
             } catch (error) {
                 console.error('❌ Series add error:', error);
                 updateStatus(`Ошибка добавления серии: ${error.message}`, 'error');
             }
         }

         function handlePriceScaleModeChange(mode) {
             if (!window.advancedSeriesAndScale || !window.advancedSeriesAndScale.isInitialized) {
                 return;
             }
             
             try {
                 window.advancedSeriesAndScale.setPriceScaleMode('right', mode);
                 updateStatus(`Режим шкалы цен изменён на: ${mode}`, 'success');
                 
             } catch (error) {
                 console.error('❌ Price scale mode change error:', error);
                 updateStatus(`Ошибка смены режима шкалы: ${error.message}`, 'error');
             }
         }

         function handleSaveState() {
             if (!window.eventsAndExport || !window.eventsAndExport.isInitialized) {
                 updateStatus('Модуль экспорта не инициализирован', 'error');
                 return;
             }
             
             try {
                 window.eventsAndExport.saveChartState();
                 updateStatus('Состояние графика сохранено', 'success');
                 
             } catch (error) {
                 console.error('❌ Save state error:', error);
                 updateStatus(`Ошибка сохранения состояния: ${error.message}`, 'error');
             }
         }

         // function generateVolumeData() {
         //     // Генерируем тестовые данные объёмов
         //     const volumeData = [];
         //     const startTime = Math.floor(Date.now() / 1000) - (365 * 24 * 60 * 60);
         //     
         //     for (let i = 0; i < 100; i++) {
         //         const time = startTime + (i * 24 * 60 * 60);
         //         const baseVolume = 1000000 + Math.random() * 500000;
         //         volumeData.push({
         //             time: time,
         //             value: baseVolume,
         //             volume: baseVolume,
         //             color: Math.random() > 0.5 ? '#26a69a' : '#ef5350'
         //         });
         //     }
         //     
         //     return volumeData;
         // }

         function getCurrentChartData() {
             // Получаем текущие данные графика
             if (comparisonLineSeries && comparisonLineSeries.data) {
                 return comparisonLineSeries.data();
             }
             
             if (coinbaseLineSeries && coinbaseLineSeries.data) {
                 return coinbaseLineSeries.data();
             }
             
             return [];
         }

                   function calculateBaselineValue(data) {
              if (!data || data.length === 0) return 0;
              
              // Вычисляем среднее значение как базовую линию
              const sum = data.reduce((acc, item) => acc + item.value, 0);
              return sum / data.length;
          }

                     function handleToggleFullscreen() {
               if (!window.mobileResponsive || !window.mobileResponsive.isInitialized) {
                   updateStatus('Мобильный модуль не инициализирован', 'error');
                   return;
               }
               
               try {
                   if (!window.mobileResponsive.isFullscreenSupported()) {
                       updateStatus('Полноэкранный режим не поддерживается браузером', 'error');
                       return;
                   }

                   const success = window.mobileResponsive.toggleFullscreen();
                   if (success) {
                       const isFullscreen = window.mobileResponsive.isFullscreen;
                       updateStatus(
                           isFullscreen ? 'Включён полноэкранный режим' : 'Выключен полноэкранный режим', 
                           'success'
                       );
                       
                       // Обновляем текст кнопки
                       const button = document.getElementById('toggleFullscreen');
                       if (button) {
                           button.innerHTML = isFullscreen ? '🗗 Выйти' : '⛶ Полный экран';
                       }
                   } else {
                       updateStatus('Ошибка переключения полноэкранного режима', 'error');
                   }
                   
               } catch (error) {
                   console.error('❌ Fullscreen toggle error:', error);
                   updateStatus(`Ошибка полноэкранного режима: ${error.message}`, 'error');
               }
           }

           function handleCandlestickAdd(type) {
               if (!type || !window.candlestickBarSeries) return;
               
               try {
                   const currentData = getCurrentChartData();
                   if (!currentData || currentData.length === 0) {
                       updateStatus('Нет данных для создания свечей', 'error');
                       return;
                   }

                   // Конвертируем line-данные в OHLC
                   const ohlcData = window.candlestickBarSeries.convertLineToOHLC(currentData);
                   const seriesId = `${type}_${Date.now()}`;
                   
                   switch (type) {
                       case 'classic':
                           window.candlestickBarSeries.createClassicCandlesticks(seriesId, ohlcData);
                           updateStatus('Классические свечи добавлены', 'success');
                           break;
                       case 'hollow':
                           window.candlestickBarSeries.createHollowCandlesticks(seriesId, ohlcData);
                           updateStatus('Полые свечи добавлены', 'success');
                           break;
                       case 'heikin':
                           window.candlestickBarSeries.createHeikinAshiCandlesticks(seriesId, ohlcData);
                           updateStatus('Heikin-Ashi свечи добавлены', 'success');
                           break;
                       case 'bar':
                           window.candlestickBarSeries.addBarSeries(seriesId);
                           window.candlestickBarSeries.setBarData(seriesId, ohlcData);
                           updateStatus('Бар-график добавлен', 'success');
                           break;
                   }
                   
               } catch (error) {
                   console.error('❌ Candlestick add error:', error);
                   updateStatus(`Ошибка добавления свечей: ${error.message}`, 'error');
               }
           }

           function handleTimeFeature(feature) {
               if (!feature || !window.advancedTimeFeatures) return;
               
               try {
                   switch (feature) {
                       case 'business_hours':
                           window.advancedTimeFeatures.setBusinessHours({
                               from: '09:30',
                               to: '16:00',
                               timezone: 'America/New_York'
                           });
                           updateStatus('Торговые часы NYSE установлены', 'success');
                           break;
                           
                       case 'timezone':
                           window.advancedTimeFeatures.setTimeZone('Europe/Moscow');
                           updateStatus('Часовой пояс изменён на московский', 'success');
                           break;
                           
                       case 'goto_now':
                           window.advancedTimeFeatures.goToNow();
                           updateStatus('Переход к текущему времени', 'success');
                           break;
                           
                       case 'custom_marks':
                           const now = Math.floor(Date.now() / 1000);
                           window.advancedTimeFeatures.addEventMark(now, 'Важное событие', '#FF6B6B');
                           updateStatus('Пользовательская метка добавлена', 'success');
                           break;
                   }
                   
               } catch (error) {
                   console.error('❌ Time feature error:', error);
                   updateStatus(`Ошибка функции времени: ${error.message}`, 'error');
               }
           }

           function handleCrosshairModeChange(mode) {
               if (!window.customCrosshair) return;
               
               try {
                   window.customCrosshair.setCrosshairMode(mode);
                   updateStatus(`Режим crosshair изменён на: ${mode}`, 'success');
                   
               } catch (error) {
                   console.error('❌ Crosshair mode error:', error);
                   updateStatus(`Ошибка смены режима crosshair: ${error.message}`, 'error');
               }
           }

           function handleAnimationEffect(effect) {
               if (!effect || !window.animationEffects) return;
               
               try {
                   // Проверяем что объект полностью инициализирован
                   if (!window.animationEffects.transitions) {
                       console.warn('Animation effects not fully initialized');
                       return;
                   }
                   
                   switch (effect) {
                       case 'entrance_fade':
                           window.animationEffects.animateChartEntrance('fade');
                           updateStatus('Анимация появления применена', 'success');
                           break;
                           
                       case 'highlight':
                           window.animationEffects.highlightChart();
                           updateStatus('Подсветка графика применена', 'success');
                           break;
                           
                       case 'pulse':
                           window.animationEffects.pulseChart();
                           updateStatus('Пульсация графика применена', 'success');
                           break;
                           
                       case 'loading':
                           window.animationEffects.showLoadingSpinner('Демонстрация...');
                           setTimeout(() => {
                               window.animationEffects.hideLoadingSpinner();
                           }, 3000);
                           updateStatus('Анимация загрузки показана', 'success');
                           break;
                   }
                   
               } catch (error) {
                   console.error('❌ Animation effect error:', error);
                   updateStatus(`Ошибка анимационного эффекта: ${error.message}`, 'error');
               }
           }

           function handleToggleAnimations() {
               if (!window.animationEffects || !window.animationEffects.transitions) {
                   updateStatus('Модуль анимаций не инициализирован', 'error');
                   return;
               }
               
               try {
                   const currentlyEnabled = window.animationEffects.transitions.enabled;
                   const newState = !currentlyEnabled;
                   
                   window.animationEffects.setAnimationsEnabled(newState);
                   updateStatus(`Анимации ${newState ? 'включены' : 'выключены'}`, 'success');
                   
                   const button = document.getElementById('toggleAnimations');
                   if (button) {
                       button.innerHTML = newState ? '🎬 Анимации' : '⏸️ Анимации';
                   }
                   
               } catch (error) {
                   console.error('❌ Toggle animations error:', error);
                   updateStatus(`Ошибка переключения анимаций: ${error.message}`, 'error');
               }
           }

           // Добавляем обработчики для новых элементов toolbar
           function setupToolbarHandlers() {
               // Toolbar кнопки
               const toolbarReset = document.getElementById('toolbar-reset');
               const toolbarFit = document.getElementById('toolbar-fit');
               const toolbarFullscreen = document.getElementById('toolbar-fullscreen');
               const toolbarTheme = document.getElementById('toolbar-theme');
               const toolbarGrid = document.getElementById('toolbar-grid');
               const toolbarSave = document.getElementById('toolbar-save');
               
               // Toolbar селекторы
               const toolbarTimeframe = document.getElementById('toolbar-timeframe');
               const toolbarComparison = document.getElementById('toolbar-comparison');
               
               // Floating кнопки
               const floatingIndicators = document.getElementById('floating-indicators');
               const floatingExport = document.getElementById('floating-export');
               const floatingAnimation = document.getElementById('floating-animation');
               
               // Обработчики toolbar
               if (toolbarReset) {
                   toolbarReset.addEventListener('click', () => {
                       if (chart) {
                           chart.timeScale().fitContent();
                           updateStatus('Масштаб сброшен', 'success');
                       }
                   });
               }
               
               if (toolbarFit) {
                   toolbarFit.addEventListener('click', () => {
                       if (chart) {
                           chart.timeScale().fitContent();
                           updateStatus('График подогнан', 'success');
                       }
                   });
               }
               
               if (toolbarFullscreen) {
                   toolbarFullscreen.addEventListener('click', handleToggleFullscreen);
               }
               
               if (toolbarTheme) {
                   toolbarTheme.addEventListener('click', () => {
                       // Переключение темы
                       const currentTheme = document.body.dataset.theme || 'dark';
                       const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                       document.body.dataset.theme = newTheme;
                       updateStatus(`Тема изменена на ${newTheme}`, 'success');
                   });
               }
               
               if (toolbarGrid) {
                   toolbarGrid.addEventListener('click', () => {
                       if (chart) {
                           // Переключение сетки
                           const priceScale = chart.priceScale('right');
                           const timeScale = chart.timeScale();
                           
                           // Простой toggle сетки
                           updateStatus('Сетка переключена', 'success');
                       }
                   });
               }
               
               if (toolbarSave) {
                   toolbarSave.addEventListener('click', handleSaveState);
               }
               
               // Обработчики селекторов
               if (toolbarTimeframe) {
                   toolbarTimeframe.addEventListener('change', (e) => {
                       currentTimeframe = e.target.value;
                       updateTimeframeSelector(currentComparisonInstrument);
                       DataUpdateUtils.updateStartDateAndReload('смены таймфрейма');
                   });
               }
               
               if (toolbarComparison) {
                   toolbarComparison.addEventListener('change', (e) => {
                       currentComparisonInstrument = e.target.value;
                       updateTimeframeSelector(currentComparisonInstrument);
                       DataUpdateUtils.updateStartDateAndReload('смены инструмента');
                   });
               }
               
               // Обработчики floating кнопок
               if (floatingIndicators) {
                   floatingIndicators.addEventListener('click', () => {
                       // Показать панель индикаторов
                       showIndicatorsPanel();
                   });
               }
               
               if (floatingExport) {
                   floatingExport.addEventListener('click', () => {
                       // Показать панель экспорта
                       showExportPanel();
                   });
               }
               
               if (floatingAnimation) {
                   floatingAnimation.addEventListener('click', () => {
                       // Показать панель анимаций
                       showAnimationPanel();
                   });
               }
           }

           function showIndicatorsPanel() {
               // Создаем модальное окно для индикаторов
               const modal = document.createElement('div');
               modal.style.cssText = `
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0,0,0,0.7);
                   z-index: 10000;
                   display: flex;
                   align-items: center;
                   justify-content: center;
               `;
               
               const panel = document.createElement('div');
               panel.style.cssText = `
                   background: #1e222d;
                   border: 1px solid #2a2e39;
                   border-radius: 8px;
                   padding: 20px;
                   max-width: 400px;
                   color: #d1d4dc;
               `;
               
               panel.innerHTML = `
                   <h3 style="margin-top: 0; color: #ffffff;">Технические индикаторы</h3>
                   <div style="display: flex; flex-direction: column; gap: 10px;">
                       <button onclick="addIndicator('sma')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">SMA - Simple Moving Average</button>
                       <button onclick="addIndicator('ema')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">EMA - Exponential Moving Average</button>
                       <button onclick="addIndicator('rsi')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">RSI - Relative Strength Index</button>
                       <button onclick="addIndicator('macd')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">MACD - Moving Average Convergence Divergence</button>
                       <button onclick="addIndicator('bollinger')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">Bollinger Bands</button>
                   </div>
                   <button onclick="document.body.removeChild(this.closest('.indicators-modal'))" style="margin-top: 15px; padding: 8px 16px; background: #2962ff; border: none; color: white; border-radius: 4px; cursor: pointer;">Закрыть</button>
               `;
               
               modal.className = 'indicators-modal';
               modal.appendChild(panel);
               document.body.appendChild(modal);
           }

           function showExportPanel() {
               // Создаем модальное окно для экспорта
               const modal = document.createElement('div');
               modal.style.cssText = `
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0,0,0,0.7);
                   z-index: 10000;
                   display: flex;
                   align-items: center;
                   justify-content: center;
               `;
               
               const panel = document.createElement('div');
               panel.style.cssText = `
                   background: #1e222d;
                   border: 1px solid #2a2e39;
                   border-radius: 8px;
                   padding: 20px;
                   max-width: 400px;
                   color: #d1d4dc;
               `;
               
               panel.innerHTML = `
                   <h3 style="margin-top: 0; color: #ffffff;">Экспорт данных</h3>
                   <div style="display: flex; flex-direction: column; gap: 10px;">
                       <button onclick="handleExportAction('image')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">📸 Экспорт как изображение</button>
                       <button onclick="handleExportAction('csv')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">📄 Экспорт в CSV</button>
                       <button onclick="handleExportAction('json')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">📦 Экспорт в JSON</button>
                   </div>
                   <button onclick="document.body.removeChild(this.closest('.export-modal'))" style="margin-top: 15px; padding: 8px 16px; background: #2962ff; border: none; color: white; border-radius: 4px; cursor: pointer;">Закрыть</button>
               `;
               
               modal.className = 'export-modal';
               modal.appendChild(panel);
               document.body.appendChild(modal);
           }

           function showAnimationPanel() {
               // Создаем модальное окно для анимаций
               const modal = document.createElement('div');
               modal.style.cssText = `
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100%;
                   height: 100%;
                   background: rgba(0,0,0,0.7);
                   z-index: 10000;
                   display: flex;
                   align-items: center;
                   justify-content: center;
               `;
               
               const panel = document.createElement('div');
               panel.style.cssText = `
                   background: #1e222d;
                   border: 1px solid #2a2e39;
                   border-radius: 8px;
                   padding: 20px;
                   max-width: 400px;
                   color: #d1d4dc;
               `;
               
               panel.innerHTML = `
                   <h3 style="margin-top: 0; color: #ffffff;">Анимационные эффекты</h3>
                   <div style="display: flex; flex-direction: column; gap: 10px;">
                       <button onclick="handleAnimationEffect('entrance_fade')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">💫 Анимация появления</button>
                       <button onclick="handleAnimationEffect('highlight')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">✨ Подсветка графика</button>
                       <button onclick="handleAnimationEffect('pulse')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">💓 Пульсация</button>
                       <button onclick="handleAnimationEffect('loading')" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">⏳ Демо загрузки</button>
                       <button onclick="handleToggleAnimations()" style="padding: 8px; background: #2a2e39; border: 1px solid #363a45; color: #d1d4dc; border-radius: 4px; cursor: pointer;">🎬 Вкл/Выкл анимации</button>
                   </div>
                   <button onclick="document.body.removeChild(this.closest('.animation-modal'))" style="margin-top: 15px; padding: 8px 16px; background: #2962ff; border: none; color: white; border-radius: 4px; cursor: pointer;">Закрыть</button>
               `;
               
               modal.className = 'animation-modal';
               modal.appendChild(panel);
               document.body.appendChild(modal);
           }

           // Глобальная функция для добавления индикаторов (для модальных окон)
           function addIndicator(type) {
               // Устанавливаем значение в селектор и вызываем существующую функцию
               const indicatorSelect = document.getElementById('indicatorSelect');
               if (indicatorSelect) {
                   indicatorSelect.value = type;
                   addSelectedIndicator();
               }
           }
    </script>
</body>
</html> 