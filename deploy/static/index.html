<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Instrument Chart</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script src="config.js"></script>
    <script src="optimized_utils.js"></script>
    <script src="enhanced_technical_indicators.js"></script>
    <script src="indicators_manager.js"></script>
    <script src="timescale_integration.js"></script>
    <script src="advanced_chart_features.js"></script>
    <script src="datafeed_optimization.js"></script>
    <script src="events_and_export.js"></script>
    <script src="advanced_series_and_scale.js"></script>
    <script src="mobile_responsive.js"></script>
    <script src="candlestick_bar_series.js"></script>
    <script src="advanced_time_features.js"></script>
    <script src="performance_optimizations.js"></script>
    <script src="animation_effects.js"></script>
    <script src="custom_crosshair.js"></script>
    <style>
        /* TradingView-like design */
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background: #131722;
            color: #d1d4dc;
            min-height: 100vh;
            font-size: 13px;
        }
        
        .container {
            max-width: 100%;
            margin: 0;
            background: #131722;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 44px;
        }
        
        .title {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #9db2bd;
        }
        
        .legend-line {
            width: 16px;
            height: 2px;
            border-radius: 1px;
        }
        
        .legend-comparison {
            background: #ff9800;
        }
        
        .legend-instrument {
            background: #2962ff;
        }
        
        .controls {
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
            padding: 8px 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #2a2e39;
            border: 1px solid #363a45;
            border-radius: 4px;
            padding: 6px 8px;
            transition: all 0.2s ease;
        }
        
        .control-group:hover {
            background: #323641;
            border-color: #464a57;
        }
        
        .control-group label {
            font-size: 12px;
            color: #9db2bd;
            font-weight: 400;
            white-space: nowrap;
        }
        
        .control-group select {
            border: none;
            background: transparent;
            color: #d1d4dc;
            font-size: 12px;
            cursor: pointer;
            padding: 0;
            outline: none;
            min-width: 60px;
        }
        
        .control-group select:focus {
            color: #ffffff;
        }
        
        .control-group select option {
            background: #2a2e39;
            color: #d1d4dc;
            padding: 4px 8px;
        }
        
        .date-input {
            border: none;
            background: transparent;
            color: #d1d4dc;
            font-size: 12px;
            cursor: pointer;
            padding: 0;
            outline: none;
            min-width: 100px;
        }
        
        .date-input:focus {
            color: #ffffff;
        }
        
        .reset-btn, .fit-btn {
            border: none;
            background: #2962ff;
            color: #ffffff;
            font-size: 12px;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .reset-btn:hover, .fit-btn:hover {
            background: #1e4fd4;
        }
        
        .reset-btn:active, .fit-btn:active {
            background: #1b4bc7;
        }
        
        .chart-container {
            flex: 1;
            background: #131722;
            border: none;
            margin: 0;
            overflow: hidden;
            position: relative;
        }
        
        .status {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            background: rgba(42, 46, 57, 0.9);
            color: #9db2bd;
            border: 1px solid #363a45;
            z-index: 1000;
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.1);
            color: #4caf50;
            border-color: #4caf50;
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.1);
            color: #f44336;
            border-color: #f44336;
        }
        
        .status.info {
            background: rgba(33, 150, 243, 0.1);
            color: #2196f3;
            border-color: #2196f3;
        }
        
        .data-info {
            background: #1e222d;
            border-top: 1px solid #2a2e39;
            padding: 8px 12px;
            font-size: 11px;
            color: #787b86;
            line-height: 1.4;
        }
        
        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #131722;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #2a2e39;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #363a45;
        }
        
        /* Tooltips */
        .tooltip {
            position: absolute;
            background: #2a2e39;
            color: #d1d4dc;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid #363a45;
            z-index: 1000;
            max-width: 200px;
        }
        
        /* Button variants */
        .btn-secondary {
            background: #363a45;
            color: #d1d4dc;
        }
        
        .btn-secondary:hover {
            background: #434651;
        }
        
        .btn-success {
            background: #4caf50;
            color: #ffffff;
        }
        
        .btn-success:hover {
            background: #45a049;
        }
        
        .btn-warning {
            background: #ff9800;
            color: #ffffff;
        }
        
        .btn-warning:hover {
            background: #e68900;
        }
        
        .btn-danger {
            background: #f44336;
            color: #ffffff;
        }
        
        .btn-danger:hover {
            background: #da190b;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                justify-content: space-between;
            }
            
            .header {
                flex-direction: column;
                height: auto;
                padding: 12px;
                gap: 8px;
            }
            
            .legend {
                order: 2;
            }
            
            .data-info {
                font-size: 10px;
            }
        }
        
        /* Animation enhancements */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease;
        }
        
        /* Chart-specific styles */
        .chart-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #9db2bd;
            font-size: 14px;
        }
        
        .chart-error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #f44336;
            font-size: 14px;
        }
        
        /* Enhanced control styles */
        .control-group.active {
            background: #2962ff;
            border-color: #2962ff;
        }
        
        .control-group.active label {
            color: #ffffff;
        }
        
        .control-group.active select {
            color: #ffffff;
        }
        
        /* Custom select arrow */
        .control-group select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23d1d4dc' viewBox='0 0 16 16'%3e%3cpath d='M8 13.1l-8-8 2.1-2.1 5.9 5.9 5.9-5.9 2.1 2.1-8 8z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 4px center;
            background-size: 12px;
            padding-right: 20px;
        }
        
        /* Enhanced status messages */
        .status.loading {
            background: rgba(255, 193, 7, 0.1);
            color: #ffc107;
            border-color: #ffc107;
        }
        
        .status.loading::before {
            content: "⏳ ";
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">CBMA14 Chart</div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-line legend-instrument"></div>
                    <span id="coinbase-legend">Coinbase Index</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line legend-comparison"></div>
                    <span id="comparison-legend">BTC</span>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="comparisonSelect">Сравнить с:</label>
                <select id="comparisonSelect">
                    <option value="btc" selected>BTC</option>
                    <option value="spx">S&P 500</option>
                    <option value="vix">VIX</option>
                    <option value="dxy">DXY</option>
                    <option value="total3esbtc">Total3 - BTC</option>
                    <option value="withoutbtceth">Without BTC/ETH</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="timeframeSelect">Таймфрейм:</label>
                <select id="timeframeSelect">
                    <option value="240">4H</option>
                    <option value="D">1D</option>
                    <option value="3D">3D</option>
                    <option value="W" selected>1W</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="maPeriodSelect">MA период:</label>
                <select id="maPeriodSelect">
                    <option value="7">7 дней</option>
                    <option value="14" selected>14 дней</option>
                    <option value="30">30 дней</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="fromDate">От:</label>
                <input type="date" id="fromDate" class="date-input">
            </div>
            
            <div class="control-group">
                <label for="toDate">До:</label>
                <input type="date" id="toDate" class="date-input">
            </div>
            
            <div class="control-group">
                <button id="resetScale" class="reset-btn">🔄 Сбросить масштаб</button>
            </div>
            
            <div class="control-group">
                <button id="fitContent" class="fit-btn">📏 Подогнать все</button>
            </div>
            
            <div class="control-group">
                <label for="indicatorSelect">Индикаторы:</label>
                <select id="indicatorSelect">
                    <option value="">Выберите индикатор</option>
                    <option value="sma">SMA</option>
                    <option value="ema">EMA</option>
                    <option value="rsi">RSI</option>
                    <option value="macd">MACD</option>
                    <option value="bollinger">Bollinger Bands</option>
                    <option value="stochastic">Stochastic</option>
                    <option value="cbma14">CBMA14 Enhanced</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="addIndicator" class="reset-btn">➕ Добавить</button>
            </div>
            
            <div class="control-group">
                <label>Быстрый выбор:</label>
                <select id="quickTimeRange">
                    <option value="">Выбрать диапазон</option>
                    <option value="7days">7 дней</option>
                    <option value="30days">30 дней</option>
                    <option value="3months">3 месяца</option>
                    <option value="6months">6 месяцев</option>
                    <option value="1year">1 год</option>
                    <option value="2years">2 года</option>
                    <option value="all">Все данные</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="toggleTheme" class="reset-btn">🌓 Тема</button>
            </div>
            
            <div class="control-group">
                <button id="toggleGrid" class="reset-btn">⚏ Сетка</button>
            </div>
            
            <div class="control-group">
                <label>Уровни:</label>
                <select id="addPriceLevels">
                    <option value="">Добавить уровень</option>
                    <option value="support">Поддержка</option>
                    <option value="resistance">Сопротивление</option>
                    <option value="fibonacci">Фибоначчи</option>
                    <option value="pivot">Пивоты</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Экспорт:</label>
                <select id="exportOptions">
                    <option value="">Экспорт</option>
                    <option value="image">📸 Изображение</option>
                    <option value="csv">📄 CSV</option>
                    <option value="json">📦 JSON</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Серии:</label>
                <select id="seriesOptions">
                    <option value="">Добавить серию</option>
                    <!-- <option value="volume">📊 Объёмы</option> -->
                    <option value="area">📈 Область</option>
                    <option value="baseline">📉 Базовая линия</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Шкала:</label>
                <select id="priceScaleMode">
                    <option value="normal">Обычная</option>
                    <option value="logarithmic">Логарифмическая</option>
                    <option value="percentage">Процентная</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="saveState" class="reset-btn">💾 Сохранить</button>
            </div>
            
            <div class="control-group">
                <button id="toggleFullscreen" class="reset-btn">⛶ Полный экран</button>
            </div>
            
            <div class="control-group">
                <label>Candlesticks:</label>
                <select id="candlestickOptions">
                    <option value="">Добавить свечи</option>
                    <option value="classic">🕯️ Классические</option>
                    <option value="hollow">⚪ Полые</option>
                    <option value="heikin">🎌 Heikin-Ashi</option>
                    <option value="bar">📊 Бары</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Время:</label>
                <select id="timeFeatures">
                    <option value="">Функции времени</option>
                    <option value="business_hours">🏢 Торговые часы</option>
                    <option value="timezone">🌍 Часовой пояс</option>
                    <option value="goto_now">⏰ Текущее время</option>
                    <option value="custom_marks">📍 Пользовательские метки</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Crosshair:</label>
                <select id="crosshairMode">
                    <option value="normal">Обычный</option>
                    <option value="magnet">Магнитный</option>
                    <option value="hidden">Скрытый</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Анимации:</label>
                <select id="animationEffects">
                    <option value="">Эффекты</option>
                    <option value="entrance_fade">💫 Появление</option>
                    <option value="highlight">✨ Подсветка</option>
                    <option value="pulse">💓 Пульсация</option>
                    <option value="loading">⏳ Загрузка</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="toggleAnimations" class="reset-btn">🎬 Анимации</button>
            </div>
        </div>
        
        <div class="data-info">
            📊 <strong>Coinbase Index:</strong> всегда отображается на левой оси (ранк относительно всех криптовалют) | 
            📈 <strong>Сравнение:</strong> выберите инструмент для сравнения (BTC, S&P 500, VIX, DXY и другие) |
            🕐 <strong>Таймфреймы:</strong> динамически фильтруются по поддержке инструментов (только BTC поддерживает 4H) |
            🔗 <strong>Синхронизация:</strong> графики автоматически синхронизируются по общей дате начала данных
        </div>
        
        <div class="status" id="status">Загрузка графиков...</div>
        
        <div class="chart-container" id="chart-container"></div>
    </div>

    <script>
        // Конфигурация загружается из config.js
        // CONFIG доступен глобально

        // Даты определяются динамически из реальных файлов данных
        
        // Кеш для хранения информации о датах начала данных каждого инструмента
        const instrumentDateCache = new Map();
        
        // Утилиты для работы с датами
        const DateUtils = {
            toTimestamp: (date) => Math.floor(date.getTime() / 1000),
            fromTimestamp: (timestamp) => new Date(timestamp * 1000),
            toLocaleDateString: (timestamp, locale = 'ru-RU') => new Date(timestamp * 1000).toLocaleDateString(locale),
            getDaysSinceEpoch: (date) => Math.floor(date.getTime() / (24 * 60 * 60 * 1000))
        };
        
        // Утилиты для работы с таймфреймами
        const TimeframeUtils = {
            // Мапинг таймфреймов в суффиксы для файлов
            getFileSuffix: (timeframe) => {
                const mapping = { '240': '4H', 'D': '1D', '3D': '1D', 'W': '1W' };
                return mapping[timeframe] || '1D';
            },
            
            // Мапинг таймфреймов в отображаемый текст
            getDisplayText: (timeframe) => {
                const mapping = { '240': '4H', 'D': '1D', '3D': '3D', 'W': '1W' };
                return mapping[timeframe] || '1D';
            },
            
            // Проверка нужна ли агрегация из дневных данных
            needsAggregation: (timeframe) => ['3D', 'W'].includes(timeframe),
            
            // Определение API таймфрейма
            getApiTimeframe: (timeframe) => {
                return TimeframeUtils.needsAggregation(timeframe) ? 'D' : timeframe;
            }
        };
        
        // Утилиты для работы с обновлением данных
        const DataUpdateUtils = {
            // Обновить дату начала если нужно и перезагрузить данные
            async updateStartDateAndReload(reason = 'доступности данных') {
                const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
                const fromDateInput = document.getElementById('fromDate');
                const currentFromDate = fromDateInput.value;
                
                // Если текущая дата раньше общей даты, обновляем ее
                if (!currentFromDate || new Date(currentFromDate) < new Date(commonStartDate)) {
                    fromDateInput.value = commonStartDate;
                    fromDate = commonStartDate;
                    console.log(`📅 Updated start date to: ${commonStartDate}`);
                    updateStatus(`Дата начала скорректирована до ${DateUtils.toLocaleDateString(DateUtils.toTimestamp(new Date(commonStartDate)))} из-за ${reason}`, 'info');
                }
                
                console.log('🔄 Reloading data...');
                loadData();
            }
        };
        
        let chart = null;
        let candlestickSeries = null;
        let coinbaseLineSeries = null; // Всегда показываем Coinbase Index
        let comparisonLineSeries = null; // Серия для сравнения с другими инструментами
        let currentMAPeriod = CONFIG.DEFAULT_MA_PERIOD;
        let currentTimeframe = 'W'; // По умолчанию недельный таймфрейм
        let currentComparisonInstrument = 'btc'; // Инструмент для сравнения с Coinbase
        let fromDate = null;
        let toDate = null;

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', async function() {
            // Проверяем доступность CONFIG
            if (typeof CONFIG === 'undefined') {
                console.error('❌ CONFIG not loaded! Make sure config.js is loaded before this script.');
                updateStatus('Ошибка: файл конфигурации не загружен', 'error');
                return;
            }
            
            // Проверяем доступность INSTRUMENTS в конфигурации
            if (!CONFIG.INSTRUMENTS || Object.keys(CONFIG.INSTRUMENTS).length === 0) {
                console.error('❌ INSTRUMENTS not configured! Make sure CONFIG.INSTRUMENTS is defined.');
                updateStatus('Ошибка: инструменты не настроены в конфигурации', 'error');
                return;
            }
            
            // Проверяем, что выбранный по умолчанию инструмент для сравнения существует
            if (!CONFIG.INSTRUMENTS[currentComparisonInstrument]) {
                console.warn(`⚠️ Default comparison instrument '${currentComparisonInstrument}' not found, using first available instrument.`);
                currentComparisonInstrument = Object.keys(CONFIG.INSTRUMENTS).find(key => key !== 'coinbase') || 'btc';
                console.log(`📊 Switched to comparison instrument: ${currentComparisonInstrument}`);
            }
            
            // Проверяем доступность Lightweight Charts
            if (typeof LightweightCharts === 'undefined') {
                console.error('❌ LightweightCharts not loaded! Make sure the library is loaded.');
                updateStatus('Ошибка: библиотека Lightweight Charts не загружена', 'error');
                return;
            }
            
            // Синхронизируем селектор инструментов с текущим выбранным инструментом
            const comparisonSelect = document.getElementById('comparisonSelect');
            if (comparisonSelect) {
                comparisonSelect.value = currentComparisonInstrument;
            }
            
            // Обновляем селектор таймфреймов для выбранного инструмента
            updateTimeframeSelector(currentComparisonInstrument);
            
            await initializeDates();
            initializeChart();
            setupEventHandlers();
            // Небольшая задержка перед загрузкой данных
            setTimeout(loadData, 100);
        });

        async function initializeDates() {
            // Устанавливаем даты по умолчанию: исходя из общей доступности данных
            const today = new Date();
            
            // Определяем общую начальную дату для Coinbase и инструмента сравнения
            const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
            
            toDate = today.toISOString().split('T')[0];
            fromDate = commonStartDate;
            
            document.getElementById('fromDate').value = fromDate;
            document.getElementById('toDate').value = toDate;
            
            console.log(`📅 Default date range set based on common data availability: ${fromDate} to ${toDate}`);
            console.log(`ℹ️ Note: This is the latest start date among all data sources`);
            console.log(`🕐 Default timeframe: ${currentTimeframe} (Weekly)`);
        }

        // ========================================
        // РАСШИРЕННЫЕ ТЕХНИЧЕСКИЕ ИНДИКАТОРЫ
        // ========================================
        // Используем новую Enhanced Technical Indicators библиотеку
        
        function calculateMovingAverage(values, period, type = 'SMA') {
            // Преобразуем значения в формат для индикаторов
            const data = values.map((value, index) => ({
                time: index,
                close: value
            }));
            
            // Используем расширенную библиотеку с кэшированием
            switch (type.toUpperCase()) {
                case 'EMA':
                    return TechnicalIndicators.ema(data, period).map(item => item.value);
                case 'SMA':
                default:
                    return TechnicalIndicators.sma(data, period).map(item => item.value);
            }
        }

        function aggregateDataByTimeframe(data, timeframe) {
            // Используем встроенный TimeScale API вместо самописной агрегации
            if (window.timeScaleManager && window.timeScaleManager.isInitialized) {
                return window.timeScaleManager.autoAggregateDataByVisibleRange(data, {
                    maxDataPoints: 1000,
                    minDataPoints: 100
                });
            } else {
                // Fallback на современную агрегацию если TimeScale API недоступен
                return DataAggregator.aggregateTimeSeriesData(data, timeframe);
            }
        }



        // ================================================
        // УСТАРЕВШИЕ ФУНКЦИИ УДАЛЕНЫ И ЗАМЕНЕНЫ НА 
        // СОВРЕМЕННЫЕ ИЗ optimized_utils.js
        // ================================================
        // Все функции агрегации теперь в DataAggregator



        async function loadCSVData(filePath) {
            try {
                console.log(`🔍 Loading CSV data from: ${filePath}`);
                const response = await fetch(filePath);
                
                if (!response.ok) {
                    throw new Error(`Failed to load ${filePath}: ${response.status} ${response.statusText}`);
                }
                
                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                // Находим индексы нужных колонок
                const timeIdx = headers.findIndex(h => h.trim() === 'time');
                const closeIdx = headers.findIndex(h => h.trim() === 'close');
                
                if (timeIdx === -1 || closeIdx === -1) {
                    throw new Error('Required columns (time, close) not found in CSV');
                }
                
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = line.split(',');
                    if (values.length < headers.length) continue;
                    
                    const time = parseInt(values[timeIdx]);
                    const close = parseFloat(values[closeIdx]);
                    
                    if (isNaN(time) || isNaN(close)) continue;
                    
                    data.push({
                        time: time,
                        value: close
                    });
                }
                
                console.log(`📊 Loaded ${data.length} data points from CSV`);
                return data;
                
            } catch (error) {
                console.error('❌ Error loading CSV data:', error);
                return [];
            }
        }

        async function getInstrumentFirstDate(instrumentKey, timeframe) {
            const cacheKey = `${instrumentKey}_${timeframe}`;
            
            // Проверяем кеш
            if (instrumentDateCache.has(cacheKey)) {
                return instrumentDateCache.get(cacheKey);
            }
            
            try {
                const instrument = CONFIG.INSTRUMENTS[instrumentKey];
                if (!instrument) {
                    console.error(`❌ Unknown instrument: ${instrumentKey}`);
                    return null;
                }
                

                
                let firstTimestamp = null;
                
                if (instrument.dataSource === 'json') {
                    // Для JSON данных (Coinbase Index)
                    const response = await fetch(instrument.path);
                    if (response.ok) {
                        const jsonData = await response.json();
                        if (jsonData.data && jsonData.data.length > 0) {
                            // Находим первую валидную дату
                            for (const item of jsonData.data) {
                                if (item.date && item.rank != null) {
                                    const timestamp = parseDateString(item.date);
                                    if (timestamp) {
                                        firstTimestamp = timestamp;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                } else if (instrument.dataSource === 'csv') {
                    // Для CSV данных (для 3D используем 1D файлы)
                    const timeframeSuffix = TimeframeUtils.getFileSuffix(timeframe);
                    const possibleFiles = [
                        `${instrument.path}TVC_${instrumentKey.toUpperCase()}, ${timeframeSuffix}.csv`,
                        `${instrument.path}SP_${instrumentKey.toUpperCase()}, ${timeframeSuffix}.csv`,
                        `${instrument.path}${instrumentKey.toUpperCase()}, ${timeframeSuffix}.csv`
                    ];
                    
                    for (const filePath of possibleFiles) {
                        try {
                            const response = await fetch(filePath);
                            if (response.ok) {
                                const csvText = await response.text();
                                const lines = csvText.split('\n');
                                
                                if (lines.length > 1) {
                                    const headers = lines[0].split(',');
                                    const timeIdx = headers.findIndex(h => h.trim() === 'time');
                                    
                                    if (timeIdx !== -1) {
                                        const firstDataLine = lines[1].split(',');
                                        if (firstDataLine.length > timeIdx) {
                                            const time = parseInt(firstDataLine[timeIdx]);
                                            if (!isNaN(time)) {
                                                firstTimestamp = time;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            continue; // Пробуем следующий файл
                        }
                    }
                }
                
                // Сохраняем в кеш
                instrumentDateCache.set(cacheKey, firstTimestamp);
                
                if (firstTimestamp) {
                    console.log(`📅 First date for ${instrumentKey} (${timeframe}): ${DateUtils.toLocaleDateString(firstTimestamp)}`);
                }
                
                return firstTimestamp;
                
            } catch (error) {
                console.error(`❌ Error getting first date for ${instrumentKey}:`, error);
                return null;
            }
        }

        async function getCommonStartDate(comparisonInstrumentKey, timeframe) {
            try {
                console.log(`🔍 Calculating common start date for Coinbase vs ${comparisonInstrumentKey} (${timeframe})`);
                
                const dates = [];
                
                // 1. Дата начала Coinbase Index (всегда показывается)
                const coinbaseStartTime = await getInstrumentFirstDate('coinbase', timeframe);
                if (coinbaseStartTime) {
                    dates.push(coinbaseStartTime);
                    console.log(`📅 Coinbase start date: ${DateUtils.toLocaleDateString(coinbaseStartTime)}`);
                }
                
                // 2. Дата начала выбранного инструмента для сравнения
                const comparisonStartTime = await getInstrumentFirstDate(comparisonInstrumentKey, timeframe);
                if (comparisonStartTime) {
                    dates.push(comparisonStartTime);
                    console.log(`📅 ${comparisonInstrumentKey} start date: ${DateUtils.toLocaleDateString(comparisonStartTime)}`);
                }
                
                // Проверяем, что у нас есть хотя бы одна дата
                if (dates.length === 0) {
                    console.warn('⚠️ No valid start dates found, using default fallback');
                    return '2017-01-01'; // Универсальный fallback
                }
                
                // Берем самую позднюю дату (максимальную)
                const commonStartTime = Math.max(...dates);
                const commonStartDate = new Date(commonStartTime * 1000).toISOString().split('T')[0];
                
                console.log(`✅ Common start date: ${commonStartDate} (${DateUtils.toLocaleDateString(commonStartTime)})`);
                
                return commonStartDate;
                
            } catch (error) {
                console.error('❌ Error calculating common start date:', error);
                return '2017-01-01'; // Универсальный fallback
            }
        }

        async function loadCoinbaseData(fromTime, toTime) {
            try {
                // Загружаем данные Coinbase Index из JSON
                const response = await fetch('/data/data.json');
                
                if (!response.ok) {
                    throw new Error(`Failed to load Coinbase data: ${response.status} ${response.statusText}`);
                }
                
                const jsonData = await response.json();
                
                if (!jsonData.data || !Array.isArray(jsonData.data)) {
                    console.error('❌ Invalid Coinbase data structure');
                    return;
                }

                // Преобразуем JSON данные
                const allData = [];
                for (const item of jsonData.data) {
                    if (!item.date || item.rank == null) continue;

                    const timestamp = parseDateString(item.date);
                    if (!timestamp) continue;

                    allData.push({
                        time: timestamp,
                        value: parseFloat(item.rank),
                    });
                }

                if (allData.length === 0) {
                    console.error('❌ No valid Coinbase data found');
                    return;
                }

                // Сортируем данные по времени
                allData.sort((a, b) => a.time - b.time);
                console.log(`📊 Sorted ${allData.length} Coinbase data points`);

                // Рассчитываем moving average
                const rawValues = allData.map(item => item.value);
                const maValues = calculateMovingAverage(rawValues, currentMAPeriod);
                
                // Создаём данные для графика
                let maData = [];
                const startIndex = currentMAPeriod - 1;
                
                for (let i = 0; i < maValues.length; i++) {
                    const originalIndex = startIndex + i;
                    if (originalIndex < allData.length) {
                        maData.push({
                            time: allData[originalIndex].time,
                            value: maValues[i]
                        });
                    }
                }

                // Агрегируем данные по выбранному таймфрейму
                maData = aggregateDataByTimeframe(maData, currentTimeframe);
                
                // Фильтруем по датам
                const filteredData = maData.filter(item => item.time >= fromTime && item.time <= toTime);

                // Инвертируем данные для правильной визуализации (чем меньше ранг, тем лучше)
                if (filteredData.length > 0) {
                    const maxRank = Math.max(...filteredData.map(d => d.value));
                    const invertedData = filteredData.map(item => ({
                        ...item,
                        value: maxRank - item.value + 1
                    }));

                    coinbaseLineSeries.setData(invertedData);
                    console.log(`🔄 Coinbase chart updated with ${invertedData.length} points (MA${currentMAPeriod}, ${currentTimeframe})`);
                }

            } catch (error) {
                console.error('❌ Error loading Coinbase data:', error);
            }
        }

        async function loadComparisonInstrumentData(fromTime, toTime) {
            try {
                const instrument = CONFIG.INSTRUMENTS[currentComparisonInstrument];
                if (!instrument) {
                    console.error(`❌ Unknown comparison instrument: ${currentComparisonInstrument}`);
                    return;
                }

                let data = [];

                if (instrument.dataSource === 'api') {
                    // Загружаем данные через API (для BTC)
                    data = await loadAPIData(instrument, fromTime, toTime);
                } else if (instrument.dataSource === 'csv') {
                    // Загружаем данные из CSV файлов
                    data = await loadInstrumentCSVData(instrument);
                    
                    // Фильтруем по датам
                    if (data.length > 0) {
                        data = data.filter(item => item.time >= fromTime && item.time <= toTime);
                    }
                }

                if (data.length === 0) {
                    console.warn(`⚠️ No data loaded for ${instrument.name}`);
                    return;
                }

                // Устанавливаем данные в соответствующую серию
                if (instrument.seriesType === 'candlestick' && candlestickSeries) {
                    candlestickSeries.setData(data);
                } else if (comparisonLineSeries) {
                    comparisonLineSeries.setData(data);
                }

                console.log(`✅ ${instrument.name} data loaded: ${data.length} points`);

            } catch (error) {
                console.error('❌ Error loading comparison instrument data:', error);
            }
        }

        async function loadAPIData(instrument, fromTime, toTime) {
            try {
                // Определяем API таймфрейм (API поддерживает только >= 4H)
                const apiTimeframe = TimeframeUtils.getApiTimeframe(currentTimeframe);
                
                if (TimeframeUtils.needsAggregation(currentTimeframe)) {
                    console.log(`📊 Loading 1D API data for ${currentTimeframe} timeframe (will be aggregated locally)`);
                }
                
                const apiUrl = `${CONFIG.API_BASE_URL}/history?symbol=${instrument.apiSymbol}&resolution=${apiTimeframe}&from=${fromTime}&to=${toTime}`;
                console.log(`🔗 API URL: ${apiUrl}`);
                
                const response = await fetch(apiUrl);
                const apiData = await response.json();
                
                console.log('📊 API Response:', apiData);

                if (apiData.s === 'ok' && apiData.t && apiData.o && apiData.h && apiData.l && apiData.c) {
                    let candleData = [];
                    for (let i = 0; i < apiData.t.length; i++) {
                        if (apiData.t[i] && apiData.o[i] != null && apiData.h[i] != null && 
                            apiData.l[i] != null && apiData.c[i] != null) {
                            candleData.push({
                                time: apiData.t[i],
                                open: parseFloat(apiData.o[i]),
                                high: parseFloat(apiData.h[i]),
                                low: parseFloat(apiData.l[i]),
                                close: parseFloat(apiData.c[i]),
                            });
                        }
                    }

                    // Агрегируем данные если нужно используя современные утилиты
                    if (currentTimeframe === 'W' && apiTimeframe === 'D') {
                        candleData = DataAggregator.aggregateTimeSeriesData(candleData, 'W');
                        console.log(`📊 API data aggregated to weekly: ${candleData.length} candles`);
                    } else if (currentTimeframe === '3D' && apiTimeframe === 'D') {
                        candleData = DataAggregator.aggregateTimeSeriesData(candleData, '3D');
                        console.log(`📊 API data aggregated to 3-day: ${candleData.length} candles`);
                    }

                    return candleData;
                } else {
                    console.error('❌ Failed to load API data:', apiData);
                    return [];
                }

            } catch (error) {
                console.error('❌ Error loading API data:', error);
                return [];
            }
        }

        async function loadInstrumentCSVData(instrument) {
            try {
                // Для 3D таймфрейма загружаем дневные данные и агрегируем их локально
                const timeframeSuffix = TimeframeUtils.getFileSuffix(currentTimeframe);
                
                if (currentTimeframe === '3D') {
                    console.log(`📊 Loading 1D CSV data for 3D timeframe (will be aggregated locally)`);
                }
                
                // Попробуем разные варианты названий файлов
                const possibleFiles = [
                    `${instrument.path}TVC_${currentComparisonInstrument.toUpperCase()}, ${timeframeSuffix}.csv`,
                    `${instrument.path}SP_${currentComparisonInstrument.toUpperCase()}, ${timeframeSuffix}.csv`,
                    `${instrument.path}${currentComparisonInstrument.toUpperCase()}, ${timeframeSuffix}.csv`
                ];
                
                for (const filePath of possibleFiles) {
                    const data = await loadCSVData(filePath);
                    if (data.length > 0) {
                        // Рассчитываем moving average если нужно
                        if (currentMAPeriod > 1) {
                            const rawValues = data.map(item => item.value);
                            const maValues = calculateMovingAverage(rawValues, currentMAPeriod);
                            
                            const maData = [];
                            const startIndex = currentMAPeriod - 1;
                            
                            for (let i = 0; i < maValues.length; i++) {
                                const originalIndex = startIndex + i;
                                if (originalIndex < data.length) {
                                    maData.push({
                                        time: data[originalIndex].time,
                                        value: maValues[i]
                                    });
                                }
                            }
                            
                            return aggregateDataByTimeframe(maData, currentTimeframe);
                        } else {
                            return aggregateDataByTimeframe(data, currentTimeframe);
                        }
                    }
                }
                
                return [];

            } catch (error) {
                console.error('❌ Error loading CSV instrument data:', error);
                return [];
            }
        }



        function createComparisonSeries() {
            try {
                // Удаляем предыдущую серию сравнения, если она существует
                if (comparisonLineSeries) {
                    chart.removeSeries(comparisonLineSeries);
                    comparisonLineSeries = null;
                }
                if (candlestickSeries) {
                    chart.removeSeries(candlestickSeries);
                    candlestickSeries = null;
                }
                
                const comparisonInstrument = CONFIG.INSTRUMENTS[currentComparisonInstrument];
                if (!comparisonInstrument) {
                    console.error(`❌ Unknown comparison instrument: ${currentComparisonInstrument}`);
                    return;
                }
                
                if (comparisonInstrument.seriesType === 'candlestick') {
                    // Создаем свечную серию (для BTC)
                    candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                        upColor: comparisonInstrument.color,
                        downColor: '#FF4976',
                        borderVisible: false,
                        wickUpColor: comparisonInstrument.color,
                        wickDownColor: '#FF4976',
                        priceScaleId: 'right',
                    });
                } else {
                    // Создаем линейную серию (для других инструментов)
                    comparisonLineSeries = chart.addSeries(LightweightCharts.LineSeries, {
                        color: comparisonInstrument.color,
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Solid,
                        lineType: LightweightCharts.LineType.Simple,
                        crosshairMarkerVisible: true,
                        crosshairMarkerRadius: 6,
                        crosshairMarkerBorderColor: comparisonInstrument.color,
                        crosshairMarkerBackgroundColor: '#FFFFFF',
                        lastValueVisible: true,
                        priceLineVisible: true,
                        priceScaleId: 'right',
                    });
                }
                
                console.log(`✅ Created ${comparisonInstrument.seriesType} series for ${comparisonInstrument.name}`);
                
            } catch (error) {
                console.error('❌ Error creating comparison series:', error);
            }
        }

        function parseDateString(dateStr) {
            try {
                // Парсим строку типа "Fri, Jul 4, 25"
                const parts = dateStr.split(',').map(s => s.trim());
                if (parts.length !== 3) return null;

                const monthDay = parts[1]; // "Jul 4"
                const year = parts[2]; // "25"

                // Преобразуем короткий год в полный
                const fullYear = year.length === 2 ? '20' + year : year;

                // Создаем полную дату
                const fullDate = `${monthDay}, ${fullYear}`;
                const date = new Date(fullDate);

                if (isNaN(date.getTime())) return null;

                return DateUtils.toTimestamp(date);
            } catch (error) {
                console.warn('⚠️ Error parsing date:', dateStr, error);
                return null;
            }
        }

        function initializeChart() {
            try {
                const container = document.getElementById('chart-container');
                
                chart = LightweightCharts.createChart(container, {
                    width: container.clientWidth,
                    height: 600,
                    layout: {
                        background: { color: '#131722' },
                        textColor: '#d1d4dc',
                        fontSize: 11,
                        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                    },
                    grid: {
                        vertLines: { 
                            color: '#2a2e39',
                            style: LightweightCharts.LineStyle.Solid,
                        },
                        horzLines: { 
                            color: '#2a2e39',
                            style: LightweightCharts.LineStyle.Solid,
                        },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: {
                            color: '#758696',
                            width: 1,
                            style: LightweightCharts.LineStyle.Solid,
                            labelBackgroundColor: '#363a45',
                        },
                        horzLine: {
                            color: '#758696',
                            width: 1,
                            style: LightweightCharts.LineStyle.Solid,
                            labelBackgroundColor: '#363a45',
                        },
                    },
                    rightPriceScale: {
                        borderColor: '#2a2e39',
                        textColor: '#d1d4dc',
                        autoScale: true,
                        mode: LightweightCharts.PriceScaleMode.Normal,
                        invertScale: false,
                        alignLabels: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                        borderVisible: true,
                        entireTextOnly: false,
                        visible: true,
                        drawTicks: true,
                        ticksVisible: true,
                    },
                    leftPriceScale: {
                        visible: true,
                        borderColor: '#2a2e39',
                        textColor: '#d1d4dc',
                        mode: LightweightCharts.PriceScaleMode.Normal,
                        invertScale: true, // Инвертируем для рангов (меньший ранг = выше)
                        autoScale: true,
                        alignLabels: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                        borderVisible: true,
                        entireTextOnly: false,
                        drawTicks: true,
                        ticksVisible: true,
                    },
                    timeScale: {
                        borderColor: '#2a2e39',
                        textColor: '#d1d4dc',
                        timeVisible: true,
                        secondsVisible: false,
                        borderVisible: true,
                        rightOffset: 12,
                        barSpacing: 3,           // Уменьшаем расстояние между барами для большей плотности
                        minBarSpacing: 0.5,      // Еще больше уменьшаем минимальное расстояние
                        fixLeftEdge: false,      // Позволяем свободно прокручивать левый край
                        fixRightEdge: false,     // Позволяем свободно прокручивать правый край
                        lockVisibleTimeRangeOnResize: false,
                        rightBarStaysOnScroll: false,  // Разрешаем свободную прокрутку
                        allowBoldLabels: true,
                        visible: true,
                        ticksVisible: true,
                        shiftVisibleRangeOnNewBar: false,  // Не сдвигаем при новых данных
                        tickMarkFormatter: (time) => {
                            const date = new Date(time * 1000);
                            return date.toLocaleDateString('ru-RU', { 
                                month: 'short', 
                                day: 'numeric' 
                            });
                        },
                    },
                    handleScroll: {
                        mouseWheel: true,          // Колесико мыши для прокрутки
                        pressedMouseMove: true,    // Прокрутка перетаскиванием
                        horzTouchDrag: true,       // Горизонтальное сенсорное перетаскивание
                        vertTouchDrag: false,      // Отключаем вертикальное перетаскивание чтобы не мешало
                    },
                    handleScale: {
                        axisPressedMouseMove: {    // Масштабирование осей мышью
                            time: true,
                            price: true,
                        },
                        mouseWheel: true,          // Масштабирование колесиком мыши
                        pinch: true,              // Масштабирование пинчем на сенсорных устройствах
                        axisDoubleClickReset: {   // Сброс масштаба двойным кликом
                            time: true,
                            price: true,
                        },
                    },
                    kineticScroll: {              // Добавляем кинетическую прокрутку
                        touch: true,
                        mouse: false,
                    },
                });

                // Проверяем доступность API Lightweight Charts
                if (!LightweightCharts.CandlestickSeries || !LightweightCharts.LineSeries) {
                    throw new Error('Required chart series types are not available');
                }

                // Создаем серию для Coinbase Index (всегда на левой оси)
                coinbaseLineSeries = chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#2962FF',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Solid,
                    lineType: LightweightCharts.LineType.Simple,
                    crosshairMarkerVisible: true,
                    crosshairMarkerRadius: 6,
                    crosshairMarkerBorderColor: '#2962FF',
                    crosshairMarkerBackgroundColor: '#FFFFFF',
                    lastValueVisible: true,
                    priceLineVisible: true,
                    priceScaleId: 'left',
                });

                // Серия для сравнения будет создана динамически в зависимости от выбранного инструмента
                createComparisonSeries();

                if (!coinbaseLineSeries) {
                    throw new Error('Failed to create Coinbase series');
                }

                // Инициализация менеджера технических индикаторов
                window.indicatorsManager = new IndicatorsManager(chart);
                console.log('✅ Technical Indicators Manager initialized');

                // Инициализация менеджера TimeScale API для замены самописной агрегации
                window.timeScaleManager = new TimeScaleManager(chart);
                console.log('✅ TimeScale Manager initialized - legacy aggregation replaced');

                // Инициализация продвинутых возможностей Lightweight Charts
                window.advancedFeatures = new AdvancedChartFeatures(chart);
                console.log('✅ Advanced Chart Features initialized');

                // Инициализация оптимизатора UDF datafeed
                window.datafeedOptimizer = new DatafeedOptimizer();
                console.log('✅ Datafeed Optimizer initialized');

                // Инициализация Events API и Export Features
                window.eventsAndExport = new ChartEventsAndExport(chart);
                console.log('✅ Events & Export initialized');

                // Инициализация расширенных типов серий и Price Scale
                window.advancedSeriesAndScale = new AdvancedSeriesAndScale(chart);
                console.log('✅ Advanced Series & Scale initialized');

                // Инициализация мобильных и адаптивных возможностей
                window.mobileResponsive = new MobileResponsiveChart(chart, container);
                console.log('✅ Mobile & Responsive initialized');

                // Инициализация Candlestick & Bar Series
                window.candlestickBarSeries = new CandlestickBarSeries(chart);
                console.log('✅ Candlestick & Bar Series initialized');

                // Инициализация Advanced Time Features
                window.advancedTimeFeatures = new AdvancedTimeFeatures(chart);
                console.log('✅ Advanced Time Features initialized');

                // Инициализация Performance Optimizations
                window.performanceOptimizations = new PerformanceOptimizations(chart);
                console.log('✅ Performance Optimizations initialized');

                // Инициализация Animation Effects
                window.animationEffects = new AnimationEffects(chart, container);
                console.log('✅ Animation Effects initialized');

                // Инициализация Custom Crosshair
                window.customCrosshair = new CustomCrosshair(chart);
                console.log('✅ Custom Crosshair initialized');

                // Обработчик изменения размера окна
                window.addEventListener('resize', () => {
                    chart.applyOptions({ width: container.clientWidth });
                });

                // Синхронизация масштабирования левой и правой шкал
                setupScaleSynchronization();
                
                // Принудительная подгонка при инициализации
                setTimeout(() => {
                    if (chart) {
                        chart.timeScale().fitContent();
                        console.log('📊 Initial chart fit applied');
                    }
                }, 100);

                console.log('✅ Lightweight Charts initialized');
                updateStatus('График инициализирован', 'success');

            } catch (error) {
                console.error('❌ Chart initialization failed:', error);
                updateStatus('Ошибка инициализации графика', 'error');
            }
        }

        async function loadData() {
            try {
                updateStatus(CONFIG.MESSAGES.LOADING, 'info');

                // Получаем выбранные даты
                const fromDateValue = document.getElementById('fromDate').value;
                const toDateValue = document.getElementById('toDate').value;
                
                // Определяем общую начальную дату для синхронизации
                const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
                const commonStartTime = DateUtils.toTimestamp(new Date(commonStartDate));
                
                // Преобразуем даты в timestamp с учетом общей начальной даты
                const requestedFromTime = fromDateValue ? DateUtils.toTimestamp(new Date(fromDateValue)) : commonStartTime;
                const effectiveFromTime = Math.max(requestedFromTime, commonStartTime); // Не раньше общей даты
                const toTime = toDateValue ? DateUtils.toTimestamp(new Date(toDateValue + 'T23:59:59')) : DateUtils.toTimestamp(new Date());
                
                console.log(`📅 Requested from: ${DateUtils.toLocaleDateString(requestedFromTime)}`);
                console.log(`📅 Common start: ${DateUtils.toLocaleDateString(commonStartTime)}`);
                console.log(`📅 Effective from: ${DateUtils.toLocaleDateString(effectiveFromTime)}`);
                console.log(`📅 To: ${DateUtils.toLocaleDateString(toTime)}`);
                
                // Используем эффективную дату для всех запросов
                const fromTime = effectiveFromTime;

                // Получаем выбранный таймфрейм
                const timeframeSelect = document.getElementById('timeframeSelect');
                currentTimeframe = timeframeSelect ? timeframeSelect.value : 'W';
                
                // 1. Всегда загружаем данные Coinbase Index
                console.log('📊 Loading Coinbase Index data...');
                await loadCoinbaseData(fromTime, toTime);
                
                // 2. Загружаем данные выбранного инструмента для сравнения
                console.log(`📊 Loading comparison instrument: ${CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name}...`);
                await loadComparisonInstrumentData(fromTime, toTime);

                // Обновляем легенду
                updateLegend();
                
                // Автоматически подгоняем график под загруженные данные
                setTimeout(() => {
                    refreshChart();
                }, 300);
                
                setTimeout(() => {
                    refreshChart();
                }, 800);
                
                // Финальная подгонка
                setTimeout(() => {
                    fitAllContent();
                }, 1200);
                
                const timeframeText = TimeframeUtils.getDisplayText(currentTimeframe);
                const coinbaseName = CONFIG.INSTRUMENTS['coinbase']?.name || 'Coinbase';
                const comparisonName = CONFIG.INSTRUMENTS[currentComparisonInstrument]?.name || 'Unknown';
                const commonDate = DateUtils.toLocaleDateString(commonStartTime);
                updateStatus(`${CONFIG.MESSAGES.SUCCESS}: ${coinbaseName} vs ${comparisonName} (MA${currentMAPeriod}, ${timeframeText}) | Синхронизировано с ${commonDate}`, 'success');

            } catch (error) {
                console.error('❌ Error loading data:', error);
                updateStatus(CONFIG.MESSAGES.ERROR, 'error');
            }
        }



        function setupScaleSynchronization() {
            if (!chart) return;
            
            try {
                // Отключаем потенциально проблемную синхронизацию
                // которая может вызывать циклические события
                
                console.log('✅ Scale synchronization setup completed (minimal)');
            } catch (error) {
                console.warn('⚠️ Scale synchronization not available:', error);
            }
        }

        function refreshChart() {
            if (!chart) {
                console.warn('⚠️ Chart not initialized, cannot refresh');
                return;
            }
            
            try {
                console.log('🔄 Refreshing chart layout...');
                
                // Принудительно подгоняем временную шкалу
                const timeScale = chart.timeScale();
                timeScale.fitContent();
                
                // Принудительно обновляем размеры
                const container = document.getElementById('chart-container');
                if (container) {
                    chart.resize(container.clientWidth, 600);
                }
                
                // Автомасштабирование ценовых шкал с принудительным обновлением
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                    console.log('📊 BTC price scale (right) refreshed');
                }
                
                const leftPriceScale = chart.priceScale('left');
                if (leftPriceScale) {
                    leftPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                    console.log('📊 Instrument price scale (left) refreshed');
                }
                
                // Дополнительная подгонка временной шкалы
                setTimeout(() => {
                    timeScale.fitContent();
                }, 50);
                
                console.log('✅ Chart refreshed successfully');
            } catch (error) {
                console.warn('⚠️ Error refreshing chart:', error);
            }
        }

        function setOptimalInitialRange() {
            if (!chart) return;
            
            try {
                console.log('🎯 Setting optimal initial time range...');
                
                // Устанавливаем видимый диапазон на последние 2 года
                const now = Math.floor(Date.now() / 1000);
                const twoYearsAgo = now - (2 * 365 * 24 * 60 * 60); // 2 года назад
                
                const timeScale = chart.timeScale();
                timeScale.setVisibleRange({
                    from: twoYearsAgo,
                    to: now
                });
                
                console.log('📊 Initial range set to last 2 years for better visibility');
            } catch (error) {
                console.warn('⚠️ Could not set initial range:', error);
            }
        }

        function resetAllScaling() {
            if (!chart) {
                console.warn('⚠️ Chart not initialized, cannot reset scaling');
                return;
            }
            
            try {
                console.log('🔄 Resetting all chart scaling...');
                
                // Используем TimeScale Manager для сброса временной шкалы
                if (window.timeScaleManager && window.timeScaleManager.isInitialized) {
                    window.timeScaleManager.resetTimeScale();
                } else {
                    // Fallback на прямой вызов
                    const timeScale = chart.timeScale();
                    if (timeScale.resetTimeScale) {
                        timeScale.resetTimeScale();
                    } else {
                        timeScale.fitContent();
                    }
                }
                
                // Сбрасываем правую ценовую шкалу (BTC)
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                }
                
                // Сбрасываем левую ценовую шкалу (выбранный инструмент)
                const leftPriceScale = chart.priceScale('left');
                if (leftPriceScale) {
                    leftPriceScale.applyOptions({
                        autoScale: true,
                        scaleMargins: {
                            top: 0.08,
                            bottom: 0.08,
                        },
                    });
                }
                
                console.log('✅ All scaling reset successfully');
                updateStatus('Масштаб всех осей сброшен', 'success');
                
            } catch (error) {
                console.warn('⚠️ Error resetting scaling:', error);
                updateStatus('Ошибка сброса масштаба', 'error');
            }
        }

        function fitAllContent() {
            if (!chart) {
                console.warn('⚠️ Chart not initialized, cannot fit content');
                return;
            }
            
            try {
                console.log('🔄 Fitting all content...');
                
                // Используем TimeScale Manager для подгонки временной шкалы
                if (window.timeScaleManager && window.timeScaleManager.isInitialized) {
                    window.timeScaleManager.fitContent();
                } else {
                    // Fallback на прямой вызов
                    chart.timeScale().fitContent();
                }
                
                // Подгоняем правую ценовую шкалу
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        autoScale: true,
                    });
                }
                
                // Подгоняем левую ценовую шкалу  
                const leftPriceScale = chart.priceScale('left');
                if (leftPriceScale) {
                    leftPriceScale.applyOptions({
                        autoScale: true,
                    });
                }
                
                console.log('✅ All content fitted successfully');
                updateStatus('Все данные подогнаны под размер графика', 'success');
                
            } catch (error) {
                console.warn('⚠️ Error fitting content:', error);
                updateStatus('Ошибка подгонки содержимого', 'error');
            }
        }

        function setupEventHandlers() {
            // Проверяем существование DOM элементов
            const requiredElements = ['comparisonSelect', 'timeframeSelect', 'maPeriodSelect', 'fromDate', 'toDate', 'resetScale', 'fitContent'];
            for (const elementId of requiredElements) {
                if (!document.getElementById(elementId)) {
                    console.error(`❌ Required DOM element not found: ${elementId}`);
                    updateStatus(`Ошибка: элемент ${elementId} не найден`, 'error');
                    return;
                }
            }
            
            // Смена инструмента для сравнения
            document.getElementById('comparisonSelect').addEventListener('change', async (e) => {
                currentComparisonInstrument = e.target.value;
                console.log(`📊 Comparison instrument changed to: ${currentComparisonInstrument}`);
                
                // Обновляем селектор таймфреймов для нового инструмента
                updateTimeframeSelector(currentComparisonInstrument);
                
                // Пересоздаем серию для нового инструмента
                createComparisonSeries();
                
                // Обновляем дату начала при смене инструмента
                await DataUpdateUtils.updateStartDateAndReload('доступности данных');
            });
            
            // Смена таймфрейма
            document.getElementById('timeframeSelect').addEventListener('change', async (e) => {
                currentTimeframe = e.target.value;
                console.log(`📊 Timeframe changed to: ${currentTimeframe}`);
                
                // Обновляем дату начала при смене таймфрейма
                await DataUpdateUtils.updateStartDateAndReload('доступности данных');
            });
            
            // Смена периода MA
            document.getElementById('maPeriodSelect').addEventListener('change', (e) => {
                currentMAPeriod = parseInt(e.target.value);
                loadData();
            });

            // Изменение дат
            document.getElementById('fromDate').addEventListener('change', async (e) => {
                const selectedDate = e.target.value;
                console.log(`📅 FROM date changed to: ${selectedDate}`);
                
                // Проверяем общую доступность данных
                const commonStartDate = await getCommonStartDate(currentComparisonInstrument, currentTimeframe);
                const commonStartTime = new Date(commonStartDate);
                const selectedTime = new Date(selectedDate);
                
                if (selectedTime < commonStartTime) {
                    console.warn(`⚠️ Selected date (${selectedDate}) is before common data availability (${commonStartDate})`);
                    updateStatus(`Выбранная дата раньше общей доступности данных (с ${DateUtils.toLocaleDateString(DateUtils.toTimestamp(new Date(commonStartDate)))}). Дата будет скорректирована.`, 'info');
                    
                    // Автоматически корректируем дату
                    e.target.value = commonStartDate;
                    fromDate = commonStartDate;
                } else {
                    fromDate = selectedDate;
                }
                
                console.log('🔄 Reloading data with new date range...');
                loadData();
            });

            document.getElementById('toDate').addEventListener('change', (e) => {
                toDate = e.target.value;
                console.log(`📅 TO date changed to: ${toDate}`);
                console.log('🔄 Reloading data with new date range...');
                loadData();
            });

            // Кнопки управления масштабом
            document.getElementById('resetScale').addEventListener('click', () => {
                console.log('🔄 Reset scale button clicked');
                resetAllScaling();
            });

            document.getElementById('fitContent').addEventListener('click', () => {
                console.log('📏 Fit content button clicked');
                fitAllContent();
            });

            // Кнопка добавления индикаторов
            document.getElementById('addIndicator').addEventListener('click', () => {
                addSelectedIndicator();
            });

            // Быстрый выбор временного диапазона
            document.getElementById('quickTimeRange').addEventListener('change', (e) => {
                handleQuickTimeRangeSelection(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // Переключение темы
            document.getElementById('toggleTheme').addEventListener('click', () => {
                toggleChartTheme();
            });

            // Переключение сетки
            document.getElementById('toggleGrid').addEventListener('click', () => {
                toggleChartGrid();
            });

            // Добавление уровней цен
            document.getElementById('addPriceLevels').addEventListener('change', (e) => {
                handlePriceLevelAdd(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // Горячие клавиши для управления масштабом
            document.addEventListener('keydown', (e) => {
                // Проверяем, что не фокусированы поля ввода
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                    return;
                }
                
                switch (e.key) {
                    case 'r':
                    case 'R':
                        e.preventDefault();
                        console.log('⌨️ Reset scale hotkey pressed (R)');
                        resetAllScaling();
                        break;
                    case 'f':
                    case 'F':
                        e.preventDefault();
                        console.log('⌨️ Fit content hotkey pressed (F)');
                        fitAllContent();
                        break;
                    case 'F11':
                        e.preventDefault();
                        console.log('⌨️ Fullscreen hotkey pressed (F11)');
                        handleToggleFullscreen();
                        break;
                }
            });

            // ===============================================
            // ОБРАБОТЧИКИ НОВЫХ ФУНКЦИЙ
            // ===============================================

            // Экспорт
            document.getElementById('exportOptions').addEventListener('change', (e) => {
                handleExportAction(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // Добавление серий
            document.getElementById('seriesOptions').addEventListener('change', (e) => {
                handleSeriesAdd(e.target.value);
                e.target.value = ''; // Сбрасываем выбор
            });

            // Изменение режима шкалы цен
            document.getElementById('priceScaleMode').addEventListener('change', (e) => {
                handlePriceScaleModeChange(e.target.value);
            });

            // Сохранение состояния
            document.getElementById('saveState').addEventListener('click', () => {
                handleSaveState();
            });

            // Полноэкранный режим
            document.getElementById('toggleFullscreen').addEventListener('click', () => {
                handleToggleFullscreen();
            });

            // Candlestick серии
            document.getElementById('candlestickOptions').addEventListener('change', (e) => {
                handleCandlestickAdd(e.target.value);
                e.target.value = '';
            });

            // Функции времени
            document.getElementById('timeFeatures').addEventListener('change', (e) => {
                handleTimeFeature(e.target.value);
                e.target.value = '';
            });

            // Режим crosshair
            document.getElementById('crosshairMode').addEventListener('change', (e) => {
                handleCrosshairModeChange(e.target.value);
            });

            // Анимационные эффекты
            document.getElementById('animationEffects').addEventListener('change', (e) => {
                handleAnimationEffect(e.target.value);
                e.target.value = '';
            });

            // Переключение анимаций
            document.getElementById('toggleAnimations').addEventListener('click', () => {
                handleToggleAnimations();
            });

            console.log('✅ All event handlers set up successfully');
        }

        function updateLegend() {
            // Обновляем легенду Coinbase Index (всегда Coinbase)
            const coinbaseLegendElement = document.getElementById('coinbase-legend');
            const coinbaseLegendLineElement = document.querySelector('.legend-instrument');
            
            if (coinbaseLegendElement && coinbaseLegendLineElement) {
                const coinbaseInstrument = CONFIG.INSTRUMENTS['coinbase'];
                if (coinbaseInstrument) {
                    coinbaseLegendElement.textContent = coinbaseInstrument.name;
                    coinbaseLegendLineElement.style.background = `linear-gradient(135deg, ${coinbaseInstrument.color}, ${coinbaseInstrument.color}aa)`;
                }
            }
            
            // Обновляем легенду инструмента сравнения
            const comparisonLegendElement = document.getElementById('comparison-legend');
            const comparisonLegendLineElement = document.querySelector('.legend-comparison');
            
            if (comparisonLegendElement && comparisonLegendLineElement) {
                const comparisonInstrument = CONFIG.INSTRUMENTS[currentComparisonInstrument];
                if (comparisonInstrument) {
                    comparisonLegendElement.textContent = comparisonInstrument.name;
                    comparisonLegendLineElement.style.background = `linear-gradient(135deg, ${comparisonInstrument.color}, ${comparisonInstrument.color}aa)`;
                }
            }
        }

        function getSupportedTimeframes(comparisonInstrumentKey) {
            // Получаем поддерживаемые таймфреймы для Coinbase и выбранного инструмента
            const coinbaseInstrument = CONFIG.INSTRUMENTS['coinbase'];
            const comparisonInstrument = CONFIG.INSTRUMENTS[comparisonInstrumentKey];
            
            if (!coinbaseInstrument || !comparisonInstrument) {
                console.warn('⚠️ Instrument not found, returning default timeframes');
                return ['D', '3D', 'W']; // Безопасный fallback
            }
            
            // Находим пересечение поддерживаемых таймфреймов
            const coinbaseTimeframes = coinbaseInstrument.supportedTimeframes || ['D', '3D', 'W'];
            const comparisonTimeframes = comparisonInstrument.supportedTimeframes || ['D', '3D', 'W'];
            
            const supportedTimeframes = coinbaseTimeframes.filter(tf => comparisonTimeframes.includes(tf));
            
            console.log(`📊 Supported timeframes for ${comparisonInstrumentKey}:`, supportedTimeframes);
            return supportedTimeframes;
        }

        function updateTimeframeSelector(comparisonInstrumentKey) {
            const timeframeSelect = document.getElementById('timeframeSelect');
            if (!timeframeSelect) {
                console.warn('⚠️ Timeframe selector not found');
                return;
            }
            
            // Получаем поддерживаемые таймфреймы
            const supportedTimeframes = getSupportedTimeframes(comparisonInstrumentKey);
            
            // Сохраняем текущий выбранный таймфрейм
            const currentSelectedTimeframe = timeframeSelect.value;
            
            // Очищаем селектор
            timeframeSelect.innerHTML = '';
            
            // Добавляем опции для поддерживаемых таймфреймов
            const timeframeOptions = {
                '240': '4H',
                'D': '1D',
                '3D': '3D',
                'W': '1W'
            };
            
            supportedTimeframes.forEach(tf => {
                const option = document.createElement('option');
                option.value = tf;
                option.textContent = timeframeOptions[tf] || tf;
                timeframeSelect.appendChild(option);
            });
            
            // Восстанавливаем выбранный таймфрейм, если он поддерживается
            if (supportedTimeframes.includes(currentSelectedTimeframe)) {
                timeframeSelect.value = currentSelectedTimeframe;
                currentTimeframe = currentSelectedTimeframe;
            } else {
                // Если текущий таймфрейм не поддерживается, выбираем первый доступный
                const newTimeframe = supportedTimeframes[0] || 'D';
                timeframeSelect.value = newTimeframe;
                currentTimeframe = newTimeframe;
                console.log(`📊 Timeframe changed to ${currentTimeframe} (${comparisonInstrumentKey} doesn't support ${currentSelectedTimeframe})`);
                updateStatus(`Таймфрейм изменен на ${currentTimeframe} (${comparisonInstrumentKey} не поддерживает ${currentSelectedTimeframe})`, 'info');
            }
            
            console.log(`✅ Timeframe selector updated for ${comparisonInstrumentKey}. Available: [${supportedTimeframes.join(', ')}], Selected: ${currentTimeframe}`);
        }

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            if (!statusEl) {
                console.warn('⚠️ Status element not found, logging message:', message);
                return;
            }
            
            statusEl.textContent = message;
            
            // Удаляем все предыдущие классы
            statusEl.className = 'status';
            
            // Добавляем соответствующий класс для типа
            switch (type) {
                case 'success':
                    statusEl.classList.add('success');
                    break;
                case 'error':
                    statusEl.classList.add('error');
                    break;
                case 'loading':
                    statusEl.classList.add('loading');
                    break;
                default:
                    statusEl.classList.add('info');
            }
        }

        // ===============================================
        // ФУНКЦИИ ДЛЯ РАБОТЫ С ТЕХНИЧЕСКИМИ ИНДИКАТОРАМИ
        // ===============================================

        function addSelectedIndicator() {
            const indicatorSelect = document.getElementById('indicatorSelect');
            const selectedType = indicatorSelect.value;
            
            if (!selectedType) {
                updateStatus('Выберите индикатор для добавления', 'error');
                return;
            }
            
            if (!window.indicatorsManager) {
                updateStatus('Менеджер индикаторов не инициализирован', 'error');
                return;
            }
            
            // Получаем данные для индикатора
            const chartData = getCombinedChartData();
            if (!chartData || chartData.length === 0) {
                updateStatus('Нет данных для расчета индикатора', 'error');
                return;
            }
            
            try {
                // Устанавливаем данные в менеджер индикаторов
                window.indicatorsManager.setData(chartData);
                
                // Определяем параметры по умолчанию для разных типов индикаторов
                const defaultParams = getDefaultIndicatorParams(selectedType);
                const indicatorName = `${selectedType}_${Date.now()}`;
                
                // Добавляем индикатор
                const success = window.indicatorsManager.addIndicator(
                    indicatorName, 
                    selectedType, 
                    defaultParams
                );
                
                if (success) {
                    updateStatus(`✅ Индикатор ${selectedType.toUpperCase()} добавлен`, 'success');
                    // Сбрасываем выбор
                    indicatorSelect.value = '';
                } else {
                    updateStatus(`❌ Ошибка добавления индикатора ${selectedType}`, 'error');
                }
                
            } catch (error) {
                console.error('❌ Error adding indicator:', error);
                updateStatus(`Ошибка добавления индикатора: ${error.message}`, 'error');
            }
        }

        function getCombinedChartData() {
            // Пытаемся получить данные из основного инструмента (comparison)
            if (comparisonLineSeries && comparisonLineSeries.data) {
                return comparisonLineSeries.data().map((item, index) => ({
                    time: item.time,
                    close: item.value,
                    high: item.value * 1.01,
                    low: item.value * 0.99,
                    open: item.value
                }));
            }
            
            // Альтернативно используем данные Coinbase Index
            if (coinbaseLineSeries && coinbaseLineSeries.data) {
                return coinbaseLineSeries.data().map((item, index) => ({
                    time: item.time,
                    close: item.value,
                    high: item.value * 1.01,
                    low: item.value * 0.99,
                    open: item.value
                }));
            }
            
            // Генерируем тестовые данные если основные недоступны
            console.warn('⚠️ No chart data available, generating test data');
            const testData = [];
            const startTime = Math.floor(Date.now() / 1000) - (365 * 24 * 60 * 60);
            
            for (let i = 0; i < 100; i++) {
                const time = startTime + (i * 24 * 60 * 60);
                const baseValue = 50000 + Math.sin(i * 0.1) * 10000;
                testData.push({
                    time: time,
                    close: baseValue,
                    high: baseValue * 1.02,
                    low: baseValue * 0.98,
                    open: baseValue
                });
            }
            
            return testData;
        }

        function getDefaultIndicatorParams(type) {
            switch (type.toLowerCase()) {
                case 'sma':
                case 'ema':
                    return { period: 14 };
                    
                case 'rsi':
                    return { period: 14 };
                    
                case 'macd':
                    return { fast: 12, slow: 26, signal: 9 };
                    
                case 'bollinger':
                case 'bb':
                    return { period: 20, stdDev: 2 };
                    
                case 'stochastic':
                case 'stoch':
                    return { k: 14, d: 3 };
                    
                case 'cbma14':
                    return { period: 14, smoothing: 3 };
                    
                default:
                    return { period: 14 };
            }
        }

        // ===============================================
        // ФУНКЦИИ ДЛЯ РАБОТЫ С TIMESCALE API
        // ===============================================

        function handleQuickTimeRangeSelection(range) {
            if (!range || !window.timeScaleManager || !window.timeScaleManager.isInitialized) {
                return;
            }
            
            try {
                switch (range) {
                    case '7days':
                        window.timeScaleManager.setLastNDays(7);
                        updateStatus('Установлен диапазон: последние 7 дней', 'success');
                        break;
                        
                    case '30days':
                        window.timeScaleManager.setLastNDays(30);
                        updateStatus('Установлен диапазон: последние 30 дней', 'success');
                        break;
                        
                    case '3months':
                        window.timeScaleManager.setLastNMonths(3);
                        updateStatus('Установлен диапазон: последние 3 месяца', 'success');
                        break;
                        
                    case '6months':
                        window.timeScaleManager.setLastNMonths(6);
                        updateStatus('Установлен диапазон: последние 6 месяцев', 'success');
                        break;
                        
                    case '1year':
                        window.timeScaleManager.setLastNMonths(12);
                        updateStatus('Установлен диапазон: последний год', 'success');
                        break;
                        
                    case '2years':
                        window.timeScaleManager.setLastNMonths(24);
                        updateStatus('Установлен диапазон: последние 2 года', 'success');
                        break;
                        
                    case 'all':
                        window.timeScaleManager.fitContent();
                        updateStatus('Показаны все доступные данные', 'success');
                        break;
                        
                    default:
                        console.warn('Unknown time range:', range);
                }
                
            } catch (error) {
                console.error('❌ Error setting time range:', error);
                updateStatus(`Ошибка установки диапазона: ${error.message}`, 'error');
            }
        }

        function getTimeScaleInfo() {
            if (!window.timeScaleManager || !window.timeScaleManager.isInitialized) {
                return null;
            }
            
            return window.timeScaleManager.getTimeScaleInfo();
        }

        function optimizeDataForCurrentView(data) {
            if (!window.timeScaleManager || !window.timeScaleManager.isInitialized) {
                return data;
            }
            
                         return window.timeScaleManager.optimizeDataForCurrentRange(data, {
                 maxDataPoints: 1000,
                 minDataPoints: 100,
                 bufferSeconds: 86400 // 1 день буфер
             });
         }

         // ===============================================
         // ФУНКЦИИ ДЛЯ РАБОТЫ С ПРОДВИНУТЫМИ ВОЗМОЖНОСТЯМИ
         // ===============================================

         function toggleChartTheme() {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 updateStatus('Продвинутые возможности не инициализированы', 'error');
                 return;
             }
             
             try {
                 const currentTheme = window.advancedFeatures.currentTheme;
                 const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                 
                 window.advancedFeatures.setTheme(newTheme);
                 updateStatus(`Тема изменена на: ${newTheme === 'light' ? 'светлую' : 'тёмную'}`, 'success');
                 
             } catch (error) {
                 console.error('❌ Theme toggle error:', error);
                 updateStatus(`Ошибка смены темы: ${error.message}`, 'error');
             }
         }

         function toggleChartGrid() {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 updateStatus('Продвинутые возможности не инициализированы', 'error');
                 return;
             }
             
             try {
                 window.advancedFeatures.toggleGrid();
                 updateStatus('Видимость сетки переключена', 'success');
                 
             } catch (error) {
                 console.error('❌ Grid toggle error:', error);
                 updateStatus(`Ошибка переключения сетки: ${error.message}`, 'error');
             }
         }

         function handlePriceLevelAdd(levelType) {
             if (!levelType || !window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 return;
             }
             
             try {
                 // Получаем текущие данные для расчета уровней
                 const currentPrice = getCurrentPrice();
                 if (!currentPrice) {
                     updateStatus('Нет данных для расчета уровней', 'error');
                     return;
                 }
                 
                 switch (levelType) {
                     case 'support':
                         addSupportLevel(currentPrice);
                         break;
                         
                     case 'resistance':
                         addResistanceLevel(currentPrice);
                         break;
                         
                     case 'fibonacci':
                         addFibonacciLevels(currentPrice);
                         break;
                         
                     case 'pivot':
                         addPivotLevels(currentPrice);
                         break;
                         
                     default:
                         console.warn('Unknown level type:', levelType);
                 }
                 
             } catch (error) {
                 console.error('❌ Price level add error:', error);
                 updateStatus(`Ошибка добавления уровня: ${error.message}`, 'error');
             }
         }

         function getCurrentPrice() {
             try {
                 // Пытаемся получить текущую цену из данных сравнения
                 if (comparisonLineSeries && comparisonLineSeries.data) {
                     const data = comparisonLineSeries.data();
                     if (data && data.length > 0) {
                         return data[data.length - 1].value;
                     }
                 }
                 
                 // Альтернативно из данных Coinbase
                 if (coinbaseLineSeries && coinbaseLineSeries.data) {
                     const data = coinbaseLineSeries.data();
                     if (data && data.length > 0) {
                         return data[data.length - 1].value;
                     }
                 }
                 
                 return null;
                 
             } catch (error) {
                 console.error('❌ Get current price error:', error);
                 return null;
             }
         }

         function addSupportLevel(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Добавляем уровень поддержки на 5% ниже текущей цены
             const supportPrice = basePrice * 0.95;
             
             window.advancedFeatures.addPriceLine(series, supportPrice, {
                 color: '#00C851',
                 title: `Поддержка: ${supportPrice.toFixed(2)}`,
                 id: `support_${Date.now()}`,
                 lineStyle: LightweightCharts.LineStyle.Dashed
             });
             
             updateStatus(`Добавлен уровень поддержки: ${supportPrice.toFixed(2)}`, 'success');
         }

         function addResistanceLevel(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Добавляем уровень сопротивления на 5% выше текущей цены
             const resistancePrice = basePrice * 1.05;
             
             window.advancedFeatures.addPriceLine(series, resistancePrice, {
                 color: '#FF4444',
                 title: `Сопротивление: ${resistancePrice.toFixed(2)}`,
                 id: `resistance_${Date.now()}`,
                 lineStyle: LightweightCharts.LineStyle.Dashed
             });
             
             updateStatus(`Добавлен уровень сопротивления: ${resistancePrice.toFixed(2)}`, 'success');
         }

         function addFibonacciLevels(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Стандартные уровни Фибоначчи
             const fibLevels = [0.236, 0.382, 0.5, 0.618, 0.786];
             const range = basePrice * 0.1; // 10% диапазон
             
             fibLevels.forEach(level => {
                 const price = basePrice + (range * level) - (range * 0.5);
                 
                 window.advancedFeatures.addPriceLine(series, price, {
                     color: '#FFB74D',
                     title: `Фибо ${(level * 100).toFixed(1)}%: ${price.toFixed(2)}`,
                     id: `fib_${level}_${Date.now()}`,
                     lineWidth: 1,
                     lineStyle: LightweightCharts.LineStyle.Dotted
                 });
             });
             
             updateStatus(`Добавлены уровни Фибоначчи (${fibLevels.length})`, 'success');
         }

         function addPivotLevels(basePrice) {
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             // Простые пивот уровни (упрощенная версия)
             const pivot = basePrice;
             const range = basePrice * 0.02; // 2% диапазон
             
             const levels = [
                 { price: pivot, label: 'Pivot', color: '#2962FF' },
                 { price: pivot + range, label: 'R1', color: '#FF6B6B' },
                 { price: pivot + range * 2, label: 'R2', color: '#FF6B6B' },
                 { price: pivot - range, label: 'S1', color: '#4ECDC4' },
                 { price: pivot - range * 2, label: 'S2', color: '#4ECDC4' }
             ];
             
             levels.forEach(level => {
                 window.advancedFeatures.addPriceLine(series, level.price, {
                     color: level.color,
                     title: `${level.label}: ${level.price.toFixed(2)}`,
                     id: `pivot_${level.label}_${Date.now()}`,
                     lineWidth: level.label === 'Pivot' ? 2 : 1
                 });
             });
             
             updateStatus(`Добавлены пивот уровни (${levels.length})`, 'success');
         }

         function addEventMarker(time, type, text) {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 return;
             }
             
             const series = comparisonLineSeries || coinbaseLineSeries;
             if (!series) return;
             
             return window.advancedFeatures.addMarker(series, time, {
                 position: type === 'bullish' ? 'belowBar' : 'aboveBar',
                 color: type === 'bullish' ? '#00C851' : '#FF4444',
                 shape: type === 'bullish' ? 'arrowUp' : 'arrowDown',
                 text: text,
                 id: `event_${Date.now()}`
             });
         }

         function getAdvancedFeaturesInfo() {
             if (!window.advancedFeatures || !window.advancedFeatures.isInitialized) {
                 return null;
             }
             
             return window.advancedFeatures.getFeatureInfo();
         }

         // ===============================================
         // ФУНКЦИИ ДЛЯ РАБОТЫ С НОВЫМИ ВОЗМОЖНОСТЯМИ
         // ===============================================

         function handleExportAction(exportType) {
             if (!exportType || !window.eventsAndExport || !window.eventsAndExport.isInitialized) {
                 return;
             }
             
             try {
                 switch (exportType) {
                     case 'image':
                         window.eventsAndExport.exportChartAsImage();
                         updateStatus('График экспортирован как изображение', 'success');
                         break;
                         
                     case 'csv':
                         window.eventsAndExport.exportDataAsCSV();
                         updateStatus('Данные экспортированы в CSV', 'success');
                         break;
                         
                     case 'json':
                         window.eventsAndExport.exportDataAsJSON();
                         updateStatus('Данные экспортированы в JSON', 'success');
                         break;
                         
                     default:
                         console.warn('Unknown export type:', exportType);
                 }
                 
             } catch (error) {
                 console.error('❌ Export error:', error);
                 updateStatus(`Ошибка экспорта: ${error.message}`, 'error');
             }
         }

         function handleSeriesAdd(seriesType) {
             if (!seriesType || !window.advancedSeriesAndScale || !window.advancedSeriesAndScale.isInitialized) {
                 return;
             }
             
             try {
                 const seriesId = `${seriesType}_${Date.now()}`;
                 
                 switch (seriesType) {
                                     // case 'volume':
                //     // Создаем тестовые данные объёмов
                //     const volumeData = generateVolumeData();
                //     window.advancedSeriesAndScale.createVolumesSeries(seriesId, volumeData);
                //     updateStatus('Серия объёмов добавлена', 'success');
                //     break;
                         
                     case 'area':
                         // Создаем область на основе текущих данных
                         const areaData = getCurrentChartData();
                         window.advancedSeriesAndScale.createTrendAreaSeries(seriesId, areaData);
                         updateStatus('Серия области добавлена', 'success');
                         break;
                         
                     case 'baseline':
                         // Создаем базовую линию
                         const baselineData = getCurrentChartData();
                         const baselineValue = calculateBaselineValue(baselineData);
                         window.advancedSeriesAndScale.createDeviationBaselineSeries(seriesId, baselineData, baselineValue);
                         updateStatus('Базовая линия добавлена', 'success');
                         break;
                         
                     default:
                         console.warn('Unknown series type:', seriesType);
                 }
                 
             } catch (error) {
                 console.error('❌ Series add error:', error);
                 updateStatus(`Ошибка добавления серии: ${error.message}`, 'error');
             }
         }

         function handlePriceScaleModeChange(mode) {
             if (!window.advancedSeriesAndScale || !window.advancedSeriesAndScale.isInitialized) {
                 return;
             }
             
             try {
                 window.advancedSeriesAndScale.setPriceScaleMode('right', mode);
                 updateStatus(`Режим шкалы цен изменён на: ${mode}`, 'success');
                 
             } catch (error) {
                 console.error('❌ Price scale mode change error:', error);
                 updateStatus(`Ошибка смены режима шкалы: ${error.message}`, 'error');
             }
         }

         function handleSaveState() {
             if (!window.eventsAndExport || !window.eventsAndExport.isInitialized) {
                 updateStatus('Модуль экспорта не инициализирован', 'error');
                 return;
             }
             
             try {
                 window.eventsAndExport.saveChartState();
                 updateStatus('Состояние графика сохранено', 'success');
                 
             } catch (error) {
                 console.error('❌ Save state error:', error);
                 updateStatus(`Ошибка сохранения состояния: ${error.message}`, 'error');
             }
         }

         // function generateVolumeData() {
         //     // Генерируем тестовые данные объёмов
         //     const volumeData = [];
         //     const startTime = Math.floor(Date.now() / 1000) - (365 * 24 * 60 * 60);
         //     
         //     for (let i = 0; i < 100; i++) {
         //         const time = startTime + (i * 24 * 60 * 60);
         //         const baseVolume = 1000000 + Math.random() * 500000;
         //         volumeData.push({
         //             time: time,
         //             value: baseVolume,
         //             volume: baseVolume,
         //             color: Math.random() > 0.5 ? '#26a69a' : '#ef5350'
         //         });
         //     }
         //     
         //     return volumeData;
         // }

         function getCurrentChartData() {
             // Получаем текущие данные графика
             if (comparisonLineSeries && comparisonLineSeries.data) {
                 return comparisonLineSeries.data();
             }
             
             if (coinbaseLineSeries && coinbaseLineSeries.data) {
                 return coinbaseLineSeries.data();
             }
             
             return [];
         }

                   function calculateBaselineValue(data) {
              if (!data || data.length === 0) return 0;
              
              // Вычисляем среднее значение как базовую линию
              const sum = data.reduce((acc, item) => acc + item.value, 0);
              return sum / data.length;
          }

                     function handleToggleFullscreen() {
               if (!window.mobileResponsive || !window.mobileResponsive.isInitialized) {
                   updateStatus('Мобильный модуль не инициализирован', 'error');
                   return;
               }
               
               try {
                   if (!window.mobileResponsive.isFullscreenSupported()) {
                       updateStatus('Полноэкранный режим не поддерживается браузером', 'error');
                       return;
                   }

                   const success = window.mobileResponsive.toggleFullscreen();
                   if (success) {
                       const isFullscreen = window.mobileResponsive.isFullscreen;
                       updateStatus(
                           isFullscreen ? 'Включён полноэкранный режим' : 'Выключен полноэкранный режим', 
                           'success'
                       );
                       
                       // Обновляем текст кнопки
                       const button = document.getElementById('toggleFullscreen');
                       if (button) {
                           button.innerHTML = isFullscreen ? '🗗 Выйти' : '⛶ Полный экран';
                       }
                   } else {
                       updateStatus('Ошибка переключения полноэкранного режима', 'error');
                   }
                   
               } catch (error) {
                   console.error('❌ Fullscreen toggle error:', error);
                   updateStatus(`Ошибка полноэкранного режима: ${error.message}`, 'error');
               }
           }

           function handleCandlestickAdd(type) {
               if (!type || !window.candlestickBarSeries) return;
               
               try {
                   const currentData = getCurrentChartData();
                   if (!currentData || currentData.length === 0) {
                       updateStatus('Нет данных для создания свечей', 'error');
                       return;
                   }

                   // Конвертируем line-данные в OHLC
                   const ohlcData = window.candlestickBarSeries.convertLineToOHLC(currentData);
                   const seriesId = `${type}_${Date.now()}`;
                   
                   switch (type) {
                       case 'classic':
                           window.candlestickBarSeries.createClassicCandlesticks(seriesId, ohlcData);
                           updateStatus('Классические свечи добавлены', 'success');
                           break;
                       case 'hollow':
                           window.candlestickBarSeries.createHollowCandlesticks(seriesId, ohlcData);
                           updateStatus('Полые свечи добавлены', 'success');
                           break;
                       case 'heikin':
                           window.candlestickBarSeries.createHeikinAshiCandlesticks(seriesId, ohlcData);
                           updateStatus('Heikin-Ashi свечи добавлены', 'success');
                           break;
                       case 'bar':
                           window.candlestickBarSeries.addBarSeries(seriesId);
                           window.candlestickBarSeries.setBarData(seriesId, ohlcData);
                           updateStatus('Бар-график добавлен', 'success');
                           break;
                   }
                   
               } catch (error) {
                   console.error('❌ Candlestick add error:', error);
                   updateStatus(`Ошибка добавления свечей: ${error.message}`, 'error');
               }
           }

           function handleTimeFeature(feature) {
               if (!feature || !window.advancedTimeFeatures) return;
               
               try {
                   switch (feature) {
                       case 'business_hours':
                           window.advancedTimeFeatures.setBusinessHours({
                               from: '09:30',
                               to: '16:00',
                               timezone: 'America/New_York'
                           });
                           updateStatus('Торговые часы NYSE установлены', 'success');
                           break;
                           
                       case 'timezone':
                           window.advancedTimeFeatures.setTimeZone('Europe/Moscow');
                           updateStatus('Часовой пояс изменён на московский', 'success');
                           break;
                           
                       case 'goto_now':
                           window.advancedTimeFeatures.goToNow();
                           updateStatus('Переход к текущему времени', 'success');
                           break;
                           
                       case 'custom_marks':
                           const now = Math.floor(Date.now() / 1000);
                           window.advancedTimeFeatures.addEventMark(now, 'Важное событие', '#FF6B6B');
                           updateStatus('Пользовательская метка добавлена', 'success');
                           break;
                   }
                   
               } catch (error) {
                   console.error('❌ Time feature error:', error);
                   updateStatus(`Ошибка функции времени: ${error.message}`, 'error');
               }
           }

           function handleCrosshairModeChange(mode) {
               if (!window.customCrosshair) return;
               
               try {
                   window.customCrosshair.setCrosshairMode(mode);
                   updateStatus(`Режим crosshair изменён на: ${mode}`, 'success');
                   
               } catch (error) {
                   console.error('❌ Crosshair mode error:', error);
                   updateStatus(`Ошибка смены режима crosshair: ${error.message}`, 'error');
               }
           }

           function handleAnimationEffect(effect) {
               if (!effect || !window.animationEffects) return;
               
               try {
                   switch (effect) {
                       case 'entrance_fade':
                           window.animationEffects.animateChartEntrance('fade');
                           updateStatus('Анимация появления применена', 'success');
                           break;
                           
                       case 'highlight':
                           window.animationEffects.highlightChart();
                           updateStatus('Подсветка графика применена', 'success');
                           break;
                           
                       case 'pulse':
                           window.animationEffects.pulseChart();
                           updateStatus('Пульсация графика применена', 'success');
                           break;
                           
                       case 'loading':
                           window.animationEffects.showLoadingSpinner('Демонстрация...');
                           setTimeout(() => {
                               window.animationEffects.hideLoadingSpinner();
                           }, 3000);
                           updateStatus('Анимация загрузки показана', 'success');
                           break;
                   }
                   
               } catch (error) {
                   console.error('❌ Animation effect error:', error);
                   updateStatus(`Ошибка анимационного эффекта: ${error.message}`, 'error');
               }
           }

           function handleToggleAnimations() {
               if (!window.animationEffects) return;
               
               try {
                   const currentlyEnabled = window.animationEffects.transitions.enabled;
                   const newState = !currentlyEnabled;
                   
                   window.animationEffects.setAnimationsEnabled(newState);
                   updateStatus(`Анимации ${newState ? 'включены' : 'выключены'}`, 'success');
                   
                   const button = document.getElementById('toggleAnimations');
                   if (button) {
                       button.innerHTML = newState ? '🎬 Анимации' : '⏸️ Анимации';
                   }
                   
               } catch (error) {
                   console.error('❌ Toggle animations error:', error);
                   updateStatus(`Ошибка переключения анимаций: ${error.message}`, 'error');
               }
           }
    </script>
</body>
</html> 